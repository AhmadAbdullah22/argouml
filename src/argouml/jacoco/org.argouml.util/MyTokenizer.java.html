<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MyTokenizer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">argouml-app</a> &gt; <a href="index.source.html" class="el_package">org.argouml.util</a> &gt; <span class="el_source">MyTokenizer.java</span></div><h1>MyTokenizer.java</h1><pre class="source lang-java linenums">/* $Id$
 *****************************************************************************
 * Copyright (c) 2009 Contributors - see below
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    tfmorris
 *****************************************************************************
 *
 * Some portions of this file was previously release using the BSD License:
 */

// Copyright (c) 1996-2006 The Regents of the University of California. All
// Rights Reserved. Permission to use, copy, modify, and distribute this
// software and its documentation without fee, and without a written
// agreement is hereby granted, provided that the above copyright notice
// and this paragraph appear in all copies.  This software program and
// documentation are copyrighted by The Regents of the University of
// California. The software program and documentation are supplied &quot;AS
// IS&quot;, without any accompanying services from The Regents. The Regents
// does not warrant that the operation of the program will be
// uninterrupted or error-free. The end-user understands that the program
// was developed for research purposes and is advised not to rely
// exclusively on the program for any reason.  IN NO EVENT SHALL THE
// UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
// SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS,
// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE. THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY
// WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
// PROVIDED HEREUNDER IS ON AN &quot;AS IS&quot; BASIS, AND THE UNIVERSITY OF
// CALIFORNIA HAS NO OBLIGATIONS TO PROVIDE MAINTENANCE, SUPPORT,
// UPDATES, ENHANCEMENTS, OR MODIFICATIONS.

package org.argouml.util;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Enumeration;
import java.util.List;
import java.util.NoSuchElementException;

/**
 * Internal class for managing the delimiters in MyTokenizer. It's rather
 * similar to CustomSeparator, but faster for short constant strings.
 */
class TokenSep {
<span class="fc" id="L52">    private TokenSep next = null;</span>
    private final String theString;
    private final int length;
    private int pattern;

    /**
     * Constructs a TokenSep that will match the String given in str.
     *
     * @param str The delimiter string.
     */
<span class="fc" id="L62">    public TokenSep(String str) {</span>
<span class="fc" id="L63">	theString = str;</span>
<span class="fc" id="L64">	length = str.length();</span>
<span class="pc bpc" id="L65" title="1 of 2 branches missed.">	if (length &gt; 32) {</span>
<span class="nc" id="L66">	    throw new IllegalArgumentException(&quot;TokenSep &quot; + str</span>
	            + &quot; is &quot; + length + &quot; (&gt; 32) chars long&quot;);
        }
<span class="fc" id="L69">	pattern = 0;</span>
<span class="fc" id="L70">    }</span>

    /**
     * Called by MyTokenizer when a new character is processed in the
     * sequence. Returns true if we have found the delimiter.
     */
    public boolean addChar(char c) {
	int i;

<span class="fc" id="L79">	pattern &lt;&lt;= 1;</span>
<span class="fc" id="L80">	pattern |= 1;</span>
<span class="fc bfc" id="L81" title="All 2 branches covered.">	for (i = 0; i &lt; length; i++) {</span>
<span class="fc bfc" id="L82" title="All 2 branches covered.">	    if (theString.charAt(i) != c) {</span>
<span class="fc" id="L83">		pattern &amp;= ~(1 &lt;&lt; i);</span>
	    }
	}

<span class="fc bfc" id="L87" title="All 2 branches covered.">	return (pattern &amp; (1 &lt;&lt; (length - 1))) != 0;</span>
    }

    /**
     * Called by MyTokenizer before starting scanning for a new token.
     */
    public void reset() {
<span class="fc" id="L94">	pattern = 0;</span>
<span class="fc" id="L95">    }</span>

    /**
     * Gets the length of this token.
     */
    public int length() {
<span class="fc" id="L101">	return length;</span>
    }

    /**
     * Gets this token.
     */
    public String getString() {
<span class="fc" id="L108">	return theString;</span>
    }

    /**
     * @param n The next to set.
     */
    public void setNext(TokenSep n) {
<span class="fc" id="L115">        this.next = n;</span>
<span class="fc" id="L116">    }</span>

    /**
     * @return Returns the next.
     */
    public TokenSep getNext() {
<span class="fc" id="L122">        return next;</span>
    }
}

/**
 * A descendent of CustomSeparator that recognizes tokens on one of two forms:
 * &lt;ul&gt;
 * &lt;li&gt;&lt;pre&gt;'chr'.....'esc' 'chr'.....'chr'&lt;/pre&gt;
 * &lt;li&gt;&lt;pre&gt;'lchr'...'lchr'...'rchr'...'esc' 'rchr'....'rchr'&lt;/pre&gt;&lt;/ul&gt;
 *
 * &lt;p&gt;The first form is suited for quoted strings, like &lt;pre&gt;&quot;...\&quot;....&quot;&lt;/pre&gt;
 * or &lt;pre&gt;'...\'...'&lt;/pre&gt;.
 *
 * &lt;p&gt;The second form is suited for expressions, like
 * &lt;pre&gt;(a+(b*c)-15*eq(a, b))&lt;/pre&gt;.
 *
 * &lt;p&gt;This is in fact the class currently used for the public separators in
 * MyTokenizer, except PAREN_EXPR_STRING_SEPARATOR and LINE_SEPARATOR.
 */
class QuotedStringSeparator extends CustomSeparator {
    private final char escChr;
    private final char startChr;
    private final char stopChr;
    private boolean esced;
    private int tokLen;
    private int level;

    /**
     * Creates a separator of the first form (see above) where
     * 'chr' = q and 'esc' = esc.
     *
     * @param q The delimiter character.
     * @param esc The escape character.
     */
    public QuotedStringSeparator(char q, char esc) {
<span class="fc" id="L157">	super(q);</span>

<span class="fc" id="L159">	esced = false;</span>
<span class="fc" id="L160">	escChr = esc;</span>
<span class="fc" id="L161">	startChr = 0;</span>
<span class="fc" id="L162">	stopChr = q;</span>
<span class="fc" id="L163">	tokLen = 0;</span>
<span class="fc" id="L164">	level = 1;</span>
<span class="fc" id="L165">    }</span>

    /**
     * Creates a separator of the second form (see above) where
     * 'lchr' = sq, 'rchr' = eq and 'esc' = esc.
     *
     * @param sq The left delimiter character.
     * @param eq The right delimiter character.
     * @param esc The escape character.
     */
    public QuotedStringSeparator(char sq, char eq, char esc) {
<span class="fc" id="L176">	super(sq);</span>

<span class="fc" id="L178">	esced = false;</span>
<span class="fc" id="L179">	escChr = esc;</span>
<span class="fc" id="L180">	startChr = sq;</span>
<span class="fc" id="L181">	stopChr = eq;</span>
<span class="fc" id="L182">	tokLen = 0;</span>
<span class="fc" id="L183">	level = 1;</span>
<span class="fc" id="L184">    }</span>

    public void reset() {
<span class="fc" id="L187">	super.reset();</span>
<span class="fc" id="L188">	tokLen = 0;</span>
<span class="fc" id="L189">	level = 1;</span>
<span class="fc" id="L190">    }</span>

    /**
     * {@inheritDoc}
     *
     * Overridden to return the entire length of the token.
     */
    public int tokenLength() {
<span class="fc" id="L198">	return super.tokenLength() + tokLen;</span>
    }

    /**
     * {@inheritDoc}
     *
     * Overridden to return true.
     *
     * @return true
     */
    public boolean hasFreePart() {
<span class="fc" id="L209">	return true;</span>
    }

    /**
     * {@inheritDoc}
     *
     * Overridden to find the end of the token.
     */
    public boolean endChar(char c) {
<span class="fc" id="L218">	tokLen++;</span>

<span class="fc bfc" id="L220" title="All 2 branches covered.">	if (esced) {</span>
<span class="fc" id="L221">	    esced = false;</span>
<span class="fc" id="L222">	    return false;</span>
	}
<span class="fc bfc" id="L224" title="All 4 branches covered.">	if (escChr != 0 &amp;&amp; c == escChr) {</span>
<span class="fc" id="L225">	    esced = true;</span>
<span class="fc" id="L226">	    return false;</span>
	}
<span class="fc bfc" id="L228" title="All 4 branches covered.">	if (startChr != 0 &amp;&amp; c == startChr) {</span>
<span class="fc" id="L229">	    level++;</span>
	}
<span class="fc bfc" id="L231" title="All 2 branches covered.">	if (c == stopChr) {</span>
<span class="fc" id="L232">	    level--;</span>
	}
<span class="fc bfc" id="L234" title="All 2 branches covered.">	return level &lt;= 0;</span>
    }
}

/**
 * A descendent of CustomSeparator that recognizes tokens on the form:
 *
 * &lt;br&gt;( &quot; \&quot; ) &quot; ' \' ) ' )
 *
 * &lt;p&gt;This is, an expression inside parentheses with proper consideration
 * for quoted strings inside the the expression.
 */
class ExprSeparatorWithStrings extends CustomSeparator {
    private boolean isSQuot;
    private boolean isDQuot;
    private boolean isEsc;
    private int tokLevel;
    private int tokLen;

    /**
     * The constructor. No choices available.
     */
    public ExprSeparatorWithStrings() {
<span class="fc" id="L257">	super('(');</span>

<span class="fc" id="L259">	isEsc = false;</span>
<span class="fc" id="L260">	isSQuot = false;</span>
<span class="fc" id="L261">	isDQuot = false;</span>
<span class="fc" id="L262">	tokLevel = 1;</span>
<span class="fc" id="L263">	tokLen = 0;</span>
<span class="fc" id="L264">    }</span>

    public void reset() {
<span class="fc" id="L267">	super.reset();</span>

<span class="fc" id="L269">	isEsc = false;</span>
<span class="fc" id="L270">	isSQuot = false;</span>
<span class="fc" id="L271">	isDQuot = false;</span>
<span class="fc" id="L272">	tokLevel = 1;</span>
<span class="fc" id="L273">	tokLen = 0;</span>
<span class="fc" id="L274">    }</span>

    /**
     * {@inheritDoc}
     *
     * Overridden to return the entire length of the token.
     */
    public int tokenLength() {
<span class="fc" id="L282">	return super.tokenLength() + tokLen;</span>
    }

    /**
     * {@inheritDoc}
     *
     * Overridden to return true.
     *
     * @return true
     */
    public boolean hasFreePart() {
<span class="fc" id="L293">	return true;</span>
    }

    /**
     * {@inheritDoc}
     *
     * Overridden to find the end of the token.
     */
    public boolean endChar(char c) {
<span class="fc" id="L302">	tokLen++;</span>
<span class="fc bfc" id="L303" title="All 2 branches covered.">	if (isSQuot) {</span>
<span class="fc bfc" id="L304" title="All 2 branches covered.">	    if (isEsc) {</span>
<span class="fc" id="L305">		isEsc = false;</span>
<span class="fc" id="L306">		return false;</span>
	    }
<span class="fc bfc" id="L308" title="All 2 branches covered.">	    if (c == '\\') {</span>
<span class="fc" id="L309">	        isEsc = true;</span>
<span class="fc bfc" id="L310" title="All 2 branches covered.">	    } else if (c == '\'') {</span>
<span class="fc" id="L311">	        isSQuot = false;</span>
	    }
<span class="fc" id="L313">	    return false;</span>
<span class="fc bfc" id="L314" title="All 2 branches covered.">	} else if (isDQuot) {</span>
<span class="fc bfc" id="L315" title="All 2 branches covered.">	    if (isEsc) {</span>
<span class="fc" id="L316">		isEsc = false;</span>
<span class="fc" id="L317">		return false;</span>
	    }
<span class="fc bfc" id="L319" title="All 2 branches covered.">	    if (c == '\\') {</span>
<span class="fc" id="L320">	        isEsc = true;</span>
<span class="fc bfc" id="L321" title="All 2 branches covered.">	    } else if (c == '\&quot;') {</span>
<span class="fc" id="L322">	        isDQuot = false;</span>
	    }
<span class="fc" id="L324">	    return false;</span>
	} else {
<span class="fc bfc" id="L326" title="All 2 branches covered.">	    if (c == '\'') {</span>
<span class="fc" id="L327">	        isSQuot = true;</span>
<span class="fc bfc" id="L328" title="All 2 branches covered.">	    } else if (c == '\&quot;') {</span>
<span class="fc" id="L329">	        isDQuot = true;</span>
<span class="fc bfc" id="L330" title="All 2 branches covered.">	    } else if (c == '(') {</span>
<span class="fc" id="L331">	        tokLevel++;</span>
<span class="fc bfc" id="L332" title="All 2 branches covered.">	    } else if (c == ')') {</span>
<span class="fc" id="L333">	        tokLevel--;</span>
	    }
<span class="fc bfc" id="L335" title="All 2 branches covered.">	    return tokLevel &lt;= 0;</span>
	}
    }
}

/**
 * A descendent of CustomSeparator that recognizes &quot;the tree line ends&quot;:
 * &lt;ul&gt;
 * &lt;li&gt;UNIX: &amp;lt;lf&amp;gt;&lt;/li&gt;
 * &lt;li&gt;DOS: &amp;lt;cr&amp;gt; &amp;lt;lf&amp;gt;&lt;/li&gt;
 * &lt;li&gt;MAC: &amp;lt;cr&amp;gt;&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * &lt;p&gt;This is in fact the class currently used LINE_SEPARATOR in MyTokenizer.
 */
class LineSeparator extends CustomSeparator {
    private boolean hasCr;
    private boolean hasLf;
    private boolean hasPeeked;

    /**
     * Creates a LineSeparator.
     */
<span class="fc" id="L358">    public LineSeparator() {</span>
<span class="fc" id="L359">	hasCr = false;</span>
<span class="fc" id="L360">	hasLf = false;</span>
<span class="fc" id="L361">	hasPeeked = false;</span>
<span class="fc" id="L362">    }</span>

    public void reset() {
<span class="fc" id="L365">	super.reset();</span>
<span class="fc" id="L366">	hasCr = false;</span>
<span class="fc" id="L367">	hasLf = false;</span>
<span class="fc" id="L368">	hasPeeked = false;</span>
<span class="fc" id="L369">    }</span>

    /**
     * {@inheritDoc}
     */
    public int tokenLength() {
<span class="fc bfc" id="L375" title="All 4 branches covered.">	return hasCr &amp;&amp; hasLf ? 2 : 1;</span>
    }

    /**
     * {@inheritDoc}
     */
    public int getPeekCount() {
<span class="fc bfc" id="L382" title="All 2 branches covered.">	return hasPeeked ? 1 : 0;</span>
    }

    /**
     * {@inheritDoc}
     */
    public boolean hasFreePart() {
<span class="fc bfc" id="L389" title="All 2 branches covered.">	return !hasLf;</span>
    }

    /**
     * {@inheritDoc}
     *
     * Overridden to find the start of a line-end.
     */
    public boolean addChar(char c) {
<span class="fc bfc" id="L398" title="All 2 branches covered.">	if (c == '\n') {</span>
<span class="fc" id="L399">	    hasLf = true;</span>
<span class="fc" id="L400">	    return true;</span>
	}

<span class="fc bfc" id="L403" title="All 2 branches covered.">	if (c == '\r') {</span>
<span class="fc" id="L404">	    hasCr = true;</span>
<span class="fc" id="L405">	    return true;</span>
	}

<span class="fc" id="L408">	return false;</span>
    }

    /**
     * {@inheritDoc}
     *
     * Overridden to find the end of a line-end.
     */
    public boolean endChar(char c) {
<span class="fc bfc" id="L417" title="All 2 branches covered.">	if (c == '\n') {</span>
<span class="fc" id="L418">	    hasLf = true;</span>
	} else {
<span class="fc" id="L420">	    hasPeeked = true;</span>
	}

<span class="fc" id="L423">	return true;</span>
    }
}

/**
 * Class for dividing a String into any number of parts. Each part will be a
 * substring of the original String. The first part will at least contain the
 * first character in the string. All following parts will at least contain
 * the first character in the String not covered by any previous part.
 *
 * &lt;p&gt;The delim parameter to the constructors is a comma separated list of
 * tokens that should be recognized by the tokenizer. These tokens will be
 * returned by the tokenizer as tokens, and any arbitrary text between them
 * will also be returned as tokens. Since the comma has special meaning in
 * this string, it can be escaped with \ to only mean itself (like in &quot;\\,&quot;).
 * For technical reasons it is not possible for any token in this list to be
 * more than 32 characters long.
 *
 * &lt;p&gt;In addition to the delim parameter it is also possible to use custom
 * separators that allow any string that can be generated by the limited
 * version of a Turing machine that your computer is, to be used as a
 * delimiter.
 *
 * &lt;p&gt;There are some custom separators provided that you can use to get
 * things like strings in one token. These cannot be used simultaneously by
 * several tokenizers, ie they are not thread safe.
 *
 * &lt;p&gt;The tokenizer works in a kind of greedy way. When the first separator
 * token from delim is matched or any CustomSeparator returns true from
 * addChar, then it is satisfied it has found a token and does NOT check if
 * it could have found a longer token. Eg: if you have this delim string
 * &quot;&lt;,&lt;&lt;&quot;, then &quot;&lt;&lt;&quot; will never be found.
 *
 * &lt;p&gt;&lt;b&gt;Example&lt;/b&gt;&lt;br&gt;&lt;pre&gt;
 * MyTokenizer tzer = new MyTokenizer(&quot;Hello, how are you?&quot;, &quot; ,\\,&quot;);
 * while (tzer.hasMoreTokens())
 *   _cat.info(&quot;\&quot;&quot; + tzer.nextToken() + &quot;\&quot;&quot;);
 * &lt;/pre&gt;
 *
 * &lt;p&gt;Which whould yield the following output:&lt;pre&gt;
 *   &quot;Hello&quot;
 *   &quot;,&quot;
 *   &quot; &quot;
 *   &quot;how&quot;
 *   &quot; &quot;
 *   &quot;are&quot;
 *   &quot; &quot;
 *   &quot;you?&quot;
 * &lt;/pre&gt;
 *
 * @author Michael Stockman
 * @since 0.11.2
 * @see CustomSeparator
 */
public class MyTokenizer implements Enumeration {
    /** A custom separator for quoted strings enclosed in single quotes
     *  and using \ as escape character. There may not be an end quote
     *  if the tokenizer reaches the end of the String. */
<span class="fc" id="L481">    public static final CustomSeparator SINGLE_QUOTED_SEPARATOR =</span>
	new QuotedStringSeparator('\'', '\\');

    /** A custom separator for quoted strings enclosed in double quotes
     *  and using \ as escape character. There may not be an end quote
     *  if the tokenizer reaches the end of the String. */
<span class="fc" id="L487">    public static final CustomSeparator DOUBLE_QUOTED_SEPARATOR =</span>
	new QuotedStringSeparator('\&quot;', '\\');

    /** A custom separator for expressions enclosed in parentheses and
     *  matching lparams with rparams. There may not be proper matching
     *  if the tokenizer reaches the end of the String. Do not use this
     *  together with PAREN_EXPR_STRING_SEPARATOR. */
<span class="fc" id="L494">    public static final CustomSeparator PAREN_EXPR_SEPARATOR =</span>
	new QuotedStringSeparator('(', ')', '\0');

    /** A custom separator for expressions enclosed in parentheses and
     *  matching lparams with rparams. There may not be proper matching
     *  if the tokenizer reaches the end of the String. It also takes
     *  quoted strings (either single or double quotes) in the expression
     *  into consideration, unlike PAREN_EXPR_SEPARATOR. Do not use this
     *  together with PAREN_EXPR_SEPARATOR. */
<span class="fc" id="L503">    public static final CustomSeparator PAREN_EXPR_STRING_SEPARATOR =</span>
	new ExprSeparatorWithStrings();

    /** A custom separator for texts. Singles out the line ends,
     *  and consequently the lines, if they are in either dos, mac
     *  or unix format. */
<span class="fc" id="L509">    public static final CustomSeparator LINE_SEPARATOR =</span>
	new LineSeparator();

    private int sIdx;
    private final int eIdx;
    private int tokIdx;
    private final String source;
    private final TokenSep delims;
    private String savedToken;
    private int savedIdx;
    private List customSeps;
    private String putToken;

    /**
     * Constructs a new instance. See above for a description of the
     * delimiter string.
     *
     * @param string	The String to be tokenized.
     * @param delim	The String of delimiters.
     */
<span class="fc" id="L529">    public MyTokenizer(String string, String delim) {</span>
<span class="fc" id="L530">	source = string;</span>
<span class="fc" id="L531">	delims = parseDelimString(delim);</span>
<span class="fc" id="L532">	sIdx = 0;</span>
<span class="fc" id="L533">	tokIdx = 0;</span>
<span class="fc" id="L534">	eIdx = string.length();</span>
<span class="fc" id="L535">	savedToken = null;</span>
<span class="fc" id="L536">	customSeps = null;</span>
<span class="fc" id="L537">	putToken = null;</span>
<span class="fc" id="L538">    }</span>

    /**
     * Constructs a new instance. See above for a description of the
     * delimiter string and custom separators.
     *
     * @param string	The String to be tokenized.
     * @param delim	The String of delimiters.
     * @param sep	A custom separator to use.
     */
<span class="fc" id="L548">    public MyTokenizer(String string, String delim, CustomSeparator sep) {</span>
<span class="fc" id="L549">	source = string;</span>
<span class="fc" id="L550">	delims = parseDelimString(delim);</span>
<span class="fc" id="L551">	sIdx = 0;</span>
<span class="fc" id="L552">	tokIdx = 0;</span>
<span class="fc" id="L553">	eIdx = string.length();</span>
<span class="fc" id="L554">	savedToken = null;</span>
<span class="fc" id="L555">	customSeps = new ArrayList();</span>
<span class="fc" id="L556">	customSeps.add(sep);</span>
<span class="fc" id="L557">    }</span>

    /**
     * Constructs a new instance. See above for a description of the
     * delimiter string and custom separators.
     *
     * @param string	The String to be tokenized.
     * @param delim	The String of delimiters.
     * @param seps	Some container with custom separators to use.
     */
<span class="fc" id="L567">    public MyTokenizer(String string, String delim, Collection seps) {</span>
<span class="fc" id="L568">	source = string;</span>
<span class="fc" id="L569">	delims = parseDelimString(delim);</span>
<span class="fc" id="L570">	sIdx = 0;</span>
<span class="fc" id="L571">	tokIdx = 0;</span>
<span class="fc" id="L572">	eIdx = string.length();</span>
<span class="fc" id="L573">	savedToken = null;</span>
<span class="fc" id="L574">	customSeps = new ArrayList(seps);</span>
<span class="fc" id="L575">    }</span>

    /**
     * Returns true if there are more tokens left.
     *
     * @return true if another token can be fetched with nextToken.
     */
    public boolean hasMoreTokens() {
<span class="fc bfc" id="L583" title="All 6 branches covered.">	return sIdx &lt; eIdx || savedToken != null</span>
	    || putToken != null;
    }

    /**
     * Retrives the next token.
     *
     * @return The next token.
     */
    public String nextToken() {
	CustomSeparator csep;
	TokenSep sep;
<span class="fc" id="L595">	String s = null;</span>
	int i, j;

<span class="fc bfc" id="L598" title="All 2 branches covered.">	if (putToken != null) {</span>
<span class="fc" id="L599">	    s = putToken;</span>
<span class="fc" id="L600">	    putToken = null;</span>
<span class="fc" id="L601">	    return s;</span>
	}

<span class="fc bfc" id="L604" title="All 2 branches covered.">	if (savedToken != null) {</span>
<span class="fc" id="L605">	    s = savedToken;</span>
<span class="fc" id="L606">	    tokIdx = savedIdx;</span>
<span class="fc" id="L607">	    savedToken = null;</span>
<span class="fc" id="L608">	    return s;</span>
	}

<span class="fc bfc" id="L611" title="All 2 branches covered.">	if (sIdx &gt;= eIdx) {</span>
<span class="fc" id="L612">	    throw new NoSuchElementException(&quot;No more tokens available&quot;);</span>
	}

<span class="fc bfc" id="L615" title="All 2 branches covered.">	for (sep = delims; sep != null; sep = sep.getNext()) {</span>
<span class="fc" id="L616">	    sep.reset();</span>
	}

<span class="fc bfc" id="L619" title="All 2 branches covered.">	if (customSeps != null) {</span>
<span class="fc bfc" id="L620" title="All 2 branches covered.">	    for (i = 0; i &lt; customSeps.size(); i++) {</span>
<span class="fc" id="L621">	        ((CustomSeparator) customSeps.get(i)).reset();</span>
	    }
	}

<span class="fc bfc" id="L625" title="All 2 branches covered.">	for (i = sIdx; i &lt; eIdx; i++) {</span>
<span class="fc" id="L626">	    char c = source.charAt(i);</span>

<span class="fc" id="L628">	    for (j = 0; customSeps != null</span>
<span class="fc bfc" id="L629" title="All 4 branches covered.">	            &amp;&amp; j &lt; customSeps.size(); j++) {</span>
<span class="fc" id="L630">		csep = (CustomSeparator) customSeps.get(j);</span>

<span class="fc bfc" id="L632" title="All 2 branches covered.">		if (csep.addChar(c)) {</span>
<span class="fc" id="L633">		    break;</span>
		}
	    }
<span class="fc bfc" id="L636" title="All 4 branches covered.">	    if (customSeps != null &amp;&amp; j &lt; customSeps.size()) {</span>
<span class="fc" id="L637">		csep = (CustomSeparator) customSeps.get(j);</span>

<span class="fc bfc" id="L639" title="All 4 branches covered.">		while (csep.hasFreePart() &amp;&amp; i + 1 &lt; eIdx) {</span>
<span class="fc bfc" id="L640" title="All 2 branches covered.">		    if (csep.endChar(source.charAt(++i))) {</span>
<span class="fc" id="L641">		        break;</span>
		    }
		}
<span class="fc" id="L644">		i -= Math.min(csep.getPeekCount(), i);</span>

<span class="fc" id="L646">		int clen = Math.min(i + 1, source.length());</span>

<span class="fc bfc" id="L648" title="All 2 branches covered.">		if (i - sIdx + 1 &gt; csep.tokenLength()) {</span>
<span class="fc" id="L649">		    s = source.substring(sIdx,</span>
<span class="fc" id="L650">					  i - csep.tokenLength() + 1);</span>

<span class="fc" id="L652">		    savedIdx = i - csep.tokenLength() + 1;</span>
<span class="fc" id="L653">		    savedToken = source.substring(</span>
						    savedIdx, clen);
		} else {
<span class="fc" id="L656">		    s = source.substring(sIdx, clen);</span>
		}

<span class="fc" id="L659">		tokIdx = sIdx;</span>
<span class="fc" id="L660">		sIdx = i + 1;</span>
<span class="fc" id="L661">		break;</span>
	    }

<span class="fc bfc" id="L664" title="All 2 branches covered.">	    for (sep = delims; sep != null; sep = sep.getNext()) {</span>
<span class="fc bfc" id="L665" title="All 2 branches covered.">                if (sep.addChar(c)) {</span>
<span class="fc" id="L666">                    break;</span>
                }
            }
<span class="fc bfc" id="L669" title="All 2 branches covered.">	    if (sep != null) {</span>
<span class="fc bfc" id="L670" title="All 2 branches covered.">		if (i - sIdx + 1 &gt; sep.length()) {</span>
<span class="fc" id="L671">		    s = source.substring(sIdx,</span>
<span class="fc" id="L672">					  i - sep.length() + 1);</span>
<span class="fc" id="L673">		    savedIdx = i - sep.length() + 1;</span>
<span class="fc" id="L674">		    savedToken = sep.getString();</span>
		} else {
<span class="fc" id="L676">		    s = sep.getString();</span>
		}
<span class="fc" id="L678">		tokIdx = sIdx;</span>
<span class="fc" id="L679">		sIdx = i + 1;</span>
<span class="fc" id="L680">		break;</span>
	    }
	}

<span class="fc bfc" id="L684" title="All 2 branches covered.">	if (s == null) {</span>
<span class="fc" id="L685">	    s = source.substring(sIdx);</span>
<span class="fc" id="L686">	    tokIdx = sIdx;</span>
<span class="fc" id="L687">	    sIdx = eIdx;</span>
	}

<span class="fc" id="L690">	return s;</span>
    }

    /**
     * This class implements the Enumeration interface. This call maps
     * to nextToken.
     *
     * @return nextToken();
     * @see	#nextToken() nextToken
     */
    public Object nextElement() {
<span class="fc" id="L701">	return nextToken();</span>
    }

    /**
     * This class implements the Enumeration interface. This call maps
     * to hasMoreTokens.
     *
     * @return hasMoreTokens();
     * @see	#hasMoreTokens() hasMoreTokens
     */
    public boolean hasMoreElements() {
<span class="fc" id="L712">	return hasMoreTokens();</span>
    }

    /**
     * Returns the index in the string of the last token returned by
     * nextToken, or zero if no token has been retrived.
     *
     * @return The index of the last token.
     */
    public int getTokenIndex() {
<span class="fc" id="L722">	return tokIdx;</span>
    }

    /**
     * Put a token on the input stream. This will be the next token read
     * from the tokenizer. If this function is called again before the
     * last token has been read, then it will be lost.
     *
     * &lt;p&gt;The index returned from getTokenIndex will be the same for the
     * token put as that of the last token that wasn't put.
     *
     * @param s The token to put.
     * @throws NullPointerException if s is null.
     */
    public void putToken(String s) {
<span class="fc bfc" id="L737" title="All 2 branches covered.">	if (s == null) {</span>
<span class="fc" id="L738">	    throw new NullPointerException(&quot;Cannot put a null token&quot;);</span>
	}

<span class="fc" id="L741">	putToken = s;</span>
<span class="fc" id="L742">    }</span>

    /**
     * Creates a linked list of TokenSeps from the comma separated string
     * str.
     *
     * @param str The string specifying delimiter strings.
     * @return A list of TokenSeps.
     */
    private static TokenSep parseDelimString(String str) {
<span class="fc" id="L752">	TokenSep first = null;</span>
<span class="fc" id="L753">	TokenSep p = null;</span>
	int idx0, idx1, length;
<span class="fc" id="L755">	StringBuilder val = new StringBuilder();</span>
	char c;

<span class="fc" id="L758">	length = str.length();</span>
<span class="fc bfc" id="L759" title="All 2 branches covered.">	for (idx0 = 0; idx0 &lt; length;) {</span>
<span class="fc bfc" id="L760" title="All 2 branches covered.">	    for (idx1 = idx0; idx1 &lt; length; idx1++) {</span>
<span class="fc" id="L761">		c = str.charAt(idx1);</span>
<span class="fc bfc" id="L762" title="All 2 branches covered.">		if (c == '\\') {</span>
<span class="fc" id="L763">		    idx1++;</span>
<span class="pc bpc" id="L764" title="1 of 2 branches missed.">		    if (idx1 &lt; length) {</span>
<span class="fc" id="L765">		        val.append(str.charAt(idx1));</span>
		    }
<span class="fc bfc" id="L767" title="All 2 branches covered.">		} else if (c == ',') {</span>
<span class="fc" id="L768">		    break;</span>
		} else {
<span class="fc" id="L770">		    val.append(c);</span>
		}
	    }
<span class="fc" id="L773">	    idx1 = Math.min(idx1, length);</span>
<span class="pc bpc" id="L774" title="1 of 2 branches missed.">	    if (idx1 &gt; idx0) {</span>
<span class="fc" id="L775">		p = new TokenSep(val.toString());</span>
<span class="fc" id="L776">		val = new StringBuilder();</span>
<span class="fc" id="L777">		p.setNext(first);</span>
<span class="fc" id="L778">		first = p;</span>
	    }

<span class="fc" id="L781">	    idx0 = idx1 + 1;</span>
	}

<span class="fc" id="L784">	return first;</span>
    }
}

</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>