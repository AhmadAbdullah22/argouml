<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PathItemPlacement.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">argouml-app</a> &gt; <a href="index.source.html" class="el_package">org.argouml.uml.diagram.ui</a> &gt; <span class="el_source">PathItemPlacement.java</span></div><h1>PathItemPlacement.java</h1><pre class="source lang-java linenums">/* $Id$
 *****************************************************************************
 * Copyright (c) 2009-2012 Contributors - see below
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    dthompson
 *****************************************************************************
 *
 * Some portions of this file was previously release using the BSD License:
 */

// Copyright (c) 2008 Tom Morris and other contributors. All
// Rights Reserved. Permission to use, copy, modify, and distribute this
// software and its documentation without fee, and without a written
// agreement is hereby granted, provided that the above copyright notice
// and this paragraph appear in all copies.  This software program and
// documentation are copyrighted by The Contributors.
// The software program and documentation are supplied &quot;AS
// IS&quot;, without any accompanying services from The Contributors. They
// do not warrant that the operation of the program will be
// uninterrupted or error-free. The end-user understands that the program
// was developed for research purposes and is advised not to rely
// exclusively on the program for any reason.  IN NO EVENT SHALL THE
// CONTRIBUTORS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
// SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS,
// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
// THE CONTRIBUTORS HAVE BEEN ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE. THE CONTRIBUTORS SPECIFICALLY DISCLAIM ANY
// WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
// PROVIDED HEREUNDER IS ON AN &quot;AS IS&quot; BASIS, AND THE CONTRIBUTORS
// HAVE NO OBLIGATIONS TO PROVIDE MAINTENANCE, SUPPORT,
// UPDATES, ENHANCEMENTS, OR MODIFICATIONS.

package org.argouml.uml.diagram.ui;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.geom.Line2D;
import java.util.logging.Level;
import java.util.logging.Logger;

import org.tigris.gef.base.Globals;
import org.tigris.gef.base.PathConv;
import org.tigris.gef.presentation.Fig;
import org.tigris.gef.presentation.FigEdge;

/**
 * This class implements the coordinate generation required for GEF's
 * FigEdge.addPathItem. It can be used to place labels at an offset relative to
 * an anchor position along the path described by a FigEdge. For example, a
 * label can be placed in the middle of a FigEdge by using 50% or near an end by
 * using 0% width an offset of +5 or 100% with an offset of -5.
 * &lt;p&gt;
 * The calculated anchor position along the path is then used as a base to which
 * additional offsets are added. This can be either in the form of a
 * displacement vector and distance specified using an angle relative to the
 * angle of the edge at that point or a fixed x,y offset.
 * &lt;p&gt;
 * This class tries to avoid placing the itemFig so that it intersects the
 * pathFig. Note that:&lt;ul&gt;
 * &lt;li&gt;itemFig must return correct size information for this to work properly,
 * which is not currently true of all GEF figs (eg. text figs).
 * &lt;li&gt;Only the path is considered, so you can still get overlaps with the
 * connected nodes on the ends of the edges or other labels on the same edge or
 * other figs in the diagram. Using a displacement angle of 135 or -135 degrees
 * is a good way to help avoid the connected nodes.
 * &lt;/ul&gt;
 *
 * @author Tom Morris &lt;tfmorris@gmail.com&gt;
 * @since 0.27.3
 */
public class PathItemPlacement extends PathConv {

<span class="fc" id="L82">    private static final Logger LOG =</span>
<span class="fc" id="L83">        Logger.getLogger(PathItemPlacement.class.getName());</span>

<span class="pc" id="L85">    private boolean useCollisionCheck = true;</span>

<span class="pc" id="L87">    private boolean useAngle = true;</span>

<span class="pc" id="L89">    private double angle = 90; // default angle is 90 deg.</span>

    /**
     * the fig to be placed.
     */
    private Fig itemFig;

    /**
     * Percentage of the way along the path to place anchor.
     */
    private int percent;

    /**
     * Fixed delta offset from the computed percentage location.
     */
    private int pathOffset;

    /**
     * Distance along the displacement vector (ie distance from the edge)
     */
    private int vectorOffset;

    /**
     * Fixed offset to use for manual positioning.  Coordinates are interpreted
     * as an XY offset.
     */
    private Point offset;

    /**
     * Set true to keep items on same side (top or bottom) of path as
     * it rotates through vertical.
     */
<span class="pc" id="L121">    private final boolean swap = true;</span>

    /**
     * Construct a new path to coordinate conversion object which positions at a
     * percentage along a path with a given distance perpendicular to the path
     * at the anchor point.
     *
     * @param pathFig fig representing the edge which will be used for
     *            positioning.
     * @param theItemFig the fig to be placed.
     * @param pathPercent distance in integer percentages along path for anchor
     *            point from which the offset is computed.. Beginning of path is
     *            0 and end of path is 100.
     * @param displacement distance from the edge to place the fig. This is
     *            computed along the normal.
     */
    public PathItemPlacement(FigEdge pathFig, Fig theItemFig, int pathPercent,
            int displacement) {

<span class="fc" id="L140">        this(pathFig, theItemFig, pathPercent, 0, 90, displacement);</span>
<span class="fc" id="L141">    }</span>


    /**
     * Construct a new path to coordinate conversion object which positions
     * an anchor point on the path at a percentage along a path with an offset,
     * and from the anchor point at a distance measured at a given angle.
     *
     * @param pathFig fig representing the edge which will be used for
     *            positioning.
     * @param theItemFig the fig to be placed.
     * @param pathPercent distance in integer percentages along path for anchor
     *            point from which the offset is computed. Beginning of path is
     *            0 and end of path is 100.
     * @param pathDelta delta distance in coordinate space units to add to the
     *            computed percentage position
     * @param displacementAngle angle to add to computed line slope when
     *            computing the displacement vector
     * @param displacementDistance distance from the edge to place the fig. This
     *            is computed along the normal from the anchor position using
     *            pathPercent &amp; pathDelta.
     */
    public PathItemPlacement(FigEdge pathFig, Fig theItemFig, int pathPercent,
            int pathDelta,
            int displacementAngle,
            int displacementDistance) {
<span class="fc" id="L167">        super(pathFig);</span>
<span class="fc" id="L168">        itemFig = theItemFig;</span>
<span class="fc" id="L169">        setAnchor(pathPercent, pathDelta);</span>
<span class="fc" id="L170">        setDisplacementVector(displacementAngle + 180, displacementDistance);</span>
<span class="fc" id="L171">    }</span>

    /**
     * Construct a new path to coordinate conversion object which positions
     * an anchor point on the path at a percentage along a path with an offset,
     * and from the anchor point at a distance measured in X, Y coordinates.
     *
     * @param pathFig fig representing the edge which will be used for
     *            positioning.
     * @param theItemFig the fig to be placed.
     * @param pathPercent distance in integer percentages along path for anchor
     *            point from which the offset is computed. Beginning of path is
     *            0 and end of path is 100.
     * @param pathDelta delta distance in coordinate space units to add to the
     *            computed percentage position
     * @param absoluteOffset point representing XY offset from anchor to use for
     *            positioning.
     */
    public PathItemPlacement(FigEdge pathFig, Fig theItemFig, int pathPercent,
            int pathDelta, Point absoluteOffset) {
<span class="nc" id="L191">        super(pathFig);</span>
<span class="nc" id="L192">        itemFig = theItemFig;</span>
<span class="nc" id="L193">        setAnchor(pathPercent, pathDelta);</span>
<span class="nc" id="L194">        setAbsoluteOffset(absoluteOffset);</span>
<span class="nc" id="L195">    }</span>

    /**
     * Returns the Fig that this PathItemPlacement places.
     * To get the Fig of the Edge which owns this fig, use use getPathFig()
     * @see org.tigris.gef.base.PathConv#getPathFig()
     * @note Used by PGML.tee.
     * @return The fig that this path item places.
     */
    public Fig getItemFig() {
<span class="nc" id="L205">        return itemFig;</span>
    }

    /**
     * Compute a position.  This strangely named method computes a
     * position using the current set of parameters and returns the result
     * by updating the provided Point.
     *
     * @param result Point in which to return result.  Not read as input.
     *
     * @see org.tigris.gef.base.PathConv#stuffPoint(java.awt.Point)
     */
    public void stuffPoint(Point result) {
<span class="fc" id="L218">        result = getPosition(result);</span>
<span class="fc" id="L219">    }</span>

    /**
     * Get the computed target position based on the current set of parameters.
     *
     * @return the computed position
     */
    public Point getPosition() {
<span class="nc" id="L227">        return getPosition(new Point());</span>
    }

    @Override
    public Point getPoint() {
<span class="nc" id="L232">        return getPosition();</span>
    }

    /**
     * Get the anchor position.  The represents the point along the path that
     * is used as the starting point for all other calculations.
     *
     * @return the anchor position represented by the current percentage and
     *         path offset parameters
     */
    public Point getAnchorPosition() {
<span class="fc" id="L243">        int pathDistance = getPathDistance();</span>
<span class="fc" id="L244">        Point anchor = new Point();</span>
<span class="fc" id="L245">        _pathFigure.stuffPointAlongPerimeter(pathDistance, anchor);</span>
<span class="fc" id="L246">        return anchor;</span>
    }


    /**
     * Compute distance along the path based on percentage and offset, clamped
     * to the length of the path.
     *
     * @return the distance
     */
    private int getPathDistance() {
<span class="fc" id="L257">        int length = _pathFigure.getPerimeterLength();</span>
<span class="fc" id="L258">        int distance = Math.max(0, (length * percent) / 100 + pathOffset);</span>
        // Boundary condition in GEF, make sure this is LESS THAN, not equal
<span class="fc bfc" id="L260" title="All 2 branches covered.">        if (distance &gt;= length) {</span>
<span class="fc" id="L261">            distance = length - 1;</span>
        }
<span class="fc" id="L263">        return distance;</span>
    }


    /**
     * Get the computed position based on the current set of parameters.
     *
     * @param result Point in which to return result.  Not read as input, but it
     * &lt;em&gt;is&lt;/em&gt; modified.
     * @return the updated point
     */
    private Point getPosition(Point result) {

<span class="fc" id="L276">        Point anchor = getAnchorPosition();</span>
<span class="fc" id="L277">        result.setLocation(anchor);</span>

        // If we're using a fixed offset, just add it and return
        // No collision detection is done in this case
<span class="pc bpc" id="L281" title="1 of 2 branches missed.">        if (!useAngle) {</span>
<span class="nc" id="L282">            result.translate(offset.x, offset.y);</span>
<span class="nc" id="L283">            return result;</span>
        }

<span class="fc" id="L286">        double slope = getSlope();</span>
<span class="fc" id="L287">        result.setLocation(applyOffset(slope, vectorOffset, anchor));</span>

        // Check for a collision between our computed position and the edge
<span class="pc bpc" id="L290" title="1 of 2 branches missed.">        if (useCollisionCheck) {</span>
<span class="fc" id="L291">            int increment = 2; // increase offset by 2px at a time</span>

            // TODO: The size of text figs, which is what we care about most,
            // isn't computed correctly by GEF. If we got ambitious, we could
            // recompute a proper size ourselves.
<span class="fc" id="L296">            Dimension size = new Dimension(itemFig.getWidth(), itemFig</span>
<span class="fc" id="L297">                    .getHeight());</span>

            // Get the points representing the poly line for our edge
<span class="fc" id="L300">            FigEdge fp = (FigEdge) _pathFigure;</span>
<span class="fc" id="L301">            Point[] points = fp.getPoints();</span>
<span class="fc bfc" id="L302" title="All 2 branches covered.">            if (intersects(points, result, size)) {</span>

                // increase offset by increments until we're clear
<span class="fc" id="L305">                int scaledOffset = vectorOffset + increment;</span>

<span class="fc" id="L307">                int limit = 20;</span>
<span class="fc" id="L308">                int count = 0;</span>
                // limit our retries in case its too hard to get free
<span class="fc bfc" id="L310" title="All 4 branches covered.">                while (intersects(points, result, size) &amp;&amp; count++ &lt; limit) {</span>
<span class="fc" id="L311">                    result.setLocation(</span>
<span class="fc" id="L312">                            applyOffset(slope, scaledOffset, anchor));</span>
<span class="fc" id="L313">                    scaledOffset += increment;</span>
                }
                // If we timed out, give it one more try on the other side
                if (false /* count &gt;= limit */) {
                    LOG.log(Level.FINE, &quot;Retry limit exceeded.  Trying other side&quot;);
                    result.setLocation(anchor);
                    // TODO: This works for 90 degree angles, but is suboptimal
                    // for other angles. It should reflect the angle, rather
                    // than just using a negative offset along the same vector
                    result.setLocation(
                            applyOffset(slope, -vectorOffset, anchor));
                    count = 0;
                    scaledOffset = -scaledOffset;
                    while (intersects(points, result, size)
                            &amp;&amp; count++ &lt; limit) {
                        result.setLocation(
                                applyOffset(slope, scaledOffset, anchor));
                        scaledOffset += increment;
                    }
                }
//                LOG.log(Level.FINE, &quot;Final point #&quot; + count + &quot; &quot; + result
//                        + &quot; offset of &quot; + scaledOffset);
            }
        }
<span class="fc" id="L337">        return result;</span>
    }

    /**
     * Check for intersection between the segments of a poly line and a
     * rectangle.  Unlike FigEdge.intersects(), this only checks the main
     * path, not any associated path items (like ourselves).
     *
     * @param points set of points representing line segments
     * @param center position of center
     * @param size size of bounding box
     * @return true if they intersect
     */
    private boolean intersects(Point[] points, Point center, Dimension size) {
        // Convert to bounding box
        // Very screwy!  GEF sometimes uses center and sometimes upper left
        // TODO: GEF also positions text at the nominal baseline which is
        // well inside the bounding box and gives the overall size incorrectly
<span class="fc" id="L355">        Rectangle r = new Rectangle(center.x - (size.width / 2),</span>
                center.y - (size.height / 2),
                size.width, size.height);
<span class="fc" id="L358">        Line2D line = new Line2D.Double();</span>
<span class="fc bfc" id="L359" title="All 2 branches covered.">        for (int i = 0; i &lt; points.length - 1; i++) {</span>
<span class="fc" id="L360">            line.setLine(points[i], points[i + 1]);</span>
<span class="fc bfc" id="L361" title="All 2 branches covered.">            if (r.intersectsLine(line)) {</span>
<span class="fc" id="L362">                return true;</span>
            }
        }
<span class="fc" id="L365">        return false;</span>
    }

    /**
     * Convenience method to set anchor percentage distance and offset.
     *
     * @param newPercent distance as a percent of total path 0&lt;=percent&lt;=100
     * @param newOffset offset in drawing coordinate system
     */
    public void setAnchor(int newPercent, int newOffset) {
<span class="fc" id="L375">        setAnchorPercent(newPercent);</span>
<span class="fc" id="L376">        setAnchorOffset(newOffset);</span>
<span class="fc" id="L377">    }</span>

    /**
     * Set distance along path of anchor in integer percentages.
     * @param newPercent distance as a percent of total path 0&lt;=percent&lt;=100
     */
    public void setAnchorPercent(int newPercent) {
<span class="fc" id="L384">        percent = newPercent;</span>
<span class="fc" id="L385">    }</span>

    /**
     * Set offset along path to be applied to anchor after percentage based
     * location is calculated. Specified in units of the drawing coordinate
     * system.
     *
     * @param newOffset offset in drawing coordinate system
     */
    public void setAnchorOffset(int newOffset) {
<span class="fc" id="L395">        pathOffset = newOffset;</span>
<span class="fc" id="L396">    }</span>

    /**
     * Set a fixed offset from the anchor point.
     * @param newOffset a Point who's x &amp; y coordinates will be used as a
     * displacement from anchor point
     */
    public void setAbsoluteOffset(Point newOffset) {
<span class="nc" id="L404">        offset = newOffset;</span>
<span class="nc" id="L405">        useAngle = false;</span>
<span class="nc" id="L406">    }</span>

    /**
     * Attempts to set a new location for the fig being controlled
     * by this path item.  Takes the given Point which represents an x,y
     * position, and calculates the most appropriate angle and displacement
     * to achieve this new position.  Used when the user drags a label
     * on the diagram.
     * @override
     * @param newPoint The new target location for the PathItem fig.
     * @see org.tigris.gef.base.PathConv#setPoint(java.awt.Point)
     */
    public void setPoint(Point newPoint) {
<span class="nc" id="L419">        int vect[] = computeVector(newPoint);</span>
<span class="nc" id="L420">        setDisplacementAngle(vect[0]);</span>
<span class="nc" id="L421">        setDisplacementDistance(vect[1]);</span>
<span class="nc" id="L422">    }</span>


    /**
     * Compute an angle and distance which is equivalent to the given point.
     * This is a convenience method to help callers get coordinates in a form
     * that can be passed back in using {@link #setDisplacementVector(int, int)}
     *
     * @param point the desired target point
     * @return an array of two integers containing the angle and distance
     */
    public int[] computeVector(Point point) {
<span class="nc" id="L434">        Point anchor = getAnchorPosition();</span>
<span class="nc" id="L435">        int distance = (int) anchor.distance(point);</span>
<span class="nc" id="L436">        int angl = 0;</span>
<span class="nc" id="L437">        double pathSlope = getSlope();</span>
<span class="nc" id="L438">        double offsetSlope = getSlope(anchor, point);</span>

<span class="nc bnc" id="L440" title="All 4 branches missed.">        if (swap &amp;&amp; pathSlope &gt; Math.PI / 2 &amp;&amp; pathSlope &lt; Math.PI * 3 / 2) {</span>
<span class="nc" id="L441">            angl = -(int) ((offsetSlope - pathSlope) / Math.PI * 180);</span>
        }
        else {
<span class="nc" id="L444">            angl = (int) ((offsetSlope - pathSlope) / Math.PI * 180);</span>
        }

<span class="nc" id="L447">        int[] result = new int[] {angl, distance};</span>
<span class="nc" id="L448">        return result;</span>
    }

    /**
     * Set the displacement vector to the given angle and distance.
     *
     * @param vectorAngle angle in degrees relative to the edge at the anchor
     *            point.
     * @param vectorDistance distance along vector in drawing coordinate units
     */
    public void setDisplacementVector(int vectorAngle, int vectorDistance) {
<span class="fc" id="L459">        setDisplacementAngle(vectorAngle);</span>
<span class="fc" id="L460">        setDisplacementDistance(vectorDistance);</span>
<span class="fc" id="L461">    }</span>

    /**
     * Set the displacement vector to the given angle and distance.
     *
     * @param vectorAngle angle in degrees relative to the edge at the anchor
     *            point.
     * @param vectorDistance distance along vector in drawing coordinate units
     */
    public void setDisplacementVector(double vectorAngle,
            int vectorDistance) {
<span class="nc" id="L472">        setDisplacementAngle(vectorAngle);</span>
<span class="nc" id="L473">        setDisplacementDistance(vectorDistance);</span>
<span class="nc" id="L474">    }</span>

    /**
     * @param offsetAngle the new angle for the displacement vector,
     * specified in degrees relative to the edge at the anchor.
     */
    public void setDisplacementAngle(int offsetAngle) {
<span class="fc" id="L481">        angle = offsetAngle * Math.PI / 180.0;</span>
<span class="fc" id="L482">        useAngle = true;</span>
<span class="fc" id="L483">    }</span>

    /**
     * @param offsetAngle the new angle for the displacement vector,
     * specified in degrees relative to the edge at the anchor.
     */
    public void setDisplacementAngle(double offsetAngle) {
<span class="nc" id="L490">        angle = offsetAngle * Math.PI / 180.0;</span>
<span class="nc" id="L491">        useAngle = true;</span>
<span class="nc" id="L492">    }</span>

    /**
     * Set distance along displacement vector to place the figure.
     * @param newDistance distance in units of the drawing coordinate system
     */
    public void setDisplacementDistance(int newDistance) {
<span class="fc" id="L499">        vectorOffset = newDistance;</span>
<span class="fc" id="L500">        useAngle = true;</span>
<span class="fc" id="L501">    }</span>


    /**
     * Don't know what this is supposed to do since GEF has no API spec for it,
     * but we don't implement it and it'll throw an
     * UnsupportedOperationException if you try to use it.
     *
     * @param newPoint ignored
     * @see org.tigris.gef.base.PathConv#setClosestPoint(java.awt.Point)
     */
    public void setClosestPoint(Point newPoint) {
<span class="nc" id="L513">        throw new UnsupportedOperationException();</span>
    }


    /**
     * Compute slope of path at the anchor point.  Slope is computed using a
     * short segment instead of using the instantaneous slope, so it will give
     * unusual results near discontinuities in the path (ie bends).
     * @return the slope radians in the range 0 &lt; slope &lt; 2PI
     */
    private double getSlope() {

<span class="fc" id="L525">        final int slopeSegLen = 40; // segment size for computing slope</span>

<span class="fc" id="L527">        int pathLength = _pathFigure.getPerimeterLength();</span>
<span class="fc" id="L528">        int pathDistance = getPathDistance();</span>

        // Two points for line segment used to compute slope of path here
        // NOTE that this is the average slope, not instantaneous, so it will
        // give screwy results near bends in the path
<span class="fc" id="L533">        int d1 = Math.max(0, pathDistance - slopeSegLen / 2);</span>
        // If our position was clamped, try to make it up on the other end
<span class="fc" id="L535">        int d2 = Math.min(pathLength - 1, d1 + slopeSegLen);</span>
        // Can't get the slope of a point.  Just return an arbitrary point.
<span class="pc bpc" id="L537" title="1 of 2 branches missed.">        if (d1 == d2) {</span>
<span class="nc" id="L538">            return 0;</span>
        }
<span class="fc" id="L540">        Point p1 = _pathFigure.pointAlongPerimeter(d1);</span>
<span class="fc" id="L541">        Point p2 = _pathFigure.pointAlongPerimeter(d2);</span>

<span class="fc" id="L543">        double theta = getSlope(p1, p2);</span>
<span class="fc" id="L544">        return theta;</span>
    }


    /**
     * Compute the slope in radians of the line between two points.
     * @param p1 first point
     * @param p2 second point
     * @return slope in radians in the range 0&lt;=slope&lt;=2PI
     */
    private static double getSlope(Point p1, Point p2) {
        // Our angle theta is arctan(opposite/adjacent)
        // Because y increases going down the screen, positive angles are
        // clockwise rather than counterclockwise
<span class="fc" id="L558">        int opposite = p2.y - p1.y;</span>
<span class="fc" id="L559">        int adjacent = p2.x - p1.x;</span>
        double theta;
<span class="fc bfc" id="L561" title="All 2 branches covered.">        if (adjacent == 0) {</span>
            // This shouldn't happen, because of our line segment size check
<span class="fc bfc" id="L563" title="All 2 branches covered.">            if (opposite == 0) {</span>
<span class="fc" id="L564">                return 0;</span>
            }
            // &quot;We're going vertical!&quot; - Goose in &quot;Top Gun&quot;
<span class="fc bfc" id="L567" title="All 2 branches covered.">            if (opposite &lt; 0) {</span>
<span class="fc" id="L568">                theta = Math.PI * 3 / 2;</span>
            } else {
<span class="fc" id="L570">                theta = Math.PI / 2;</span>
            }
        } else {
            // Arctan only returns -PI/2 to PI/2
            // Handle the other two quadrants and normalize to 0 - 2PI
<span class="fc" id="L575">            theta = Math.atan((double) opposite / (double) adjacent);</span>
            // Quadrant II &amp; III
<span class="fc bfc" id="L577" title="All 2 branches covered.">            if (adjacent &lt; 0) {</span>
<span class="fc" id="L578">                theta += Math.PI;</span>
            }
            // Quadrant IV
<span class="fc bfc" id="L581" title="All 2 branches covered.">            if (theta &lt; 0) {</span>
<span class="fc" id="L582">                theta += Math.PI * 2;</span>
            }
        }
<span class="fc" id="L585">        return theta;</span>
    }

    /**
     * Apply an offset for a given distance along the normal vector computed
     * to the line specified by the two points.
     *
     * @param p1 point one of line to use in computing normal vector
     * @param p2 point two of line to use in computing normal vector
     * @param theOffset distance to displace fig along normal vector
     * @param anchor The start point to apply the offset from.  Not modified.
     * @return A new computed point describing the location after the offset
     * has been applied to the anchor.
     */
    private Point applyOffset(double theta, int theOffset,
            Point anchor) {

<span class="fc" id="L602">        Point result = new Point(anchor);</span>

        // Set the following for some backward compatibility with old algorithm
<span class="fc" id="L605">        final boolean aboveAndRight = false;</span>

//        LOG.log(Level.FINE, &quot;Slope = &quot; + theta / Math.PI + &quot;PI &quot;
//                + theta / Math.PI * 180.0);

        // Add displacement angle to slope
<span class="fc bfc" id="L611" title="All 4 branches covered.">        if (swap &amp;&amp; theta &gt; Math.PI / 2 &amp;&amp; theta &lt; Math.PI * 3 / 2) {</span>
<span class="fc" id="L612">            theta = theta - angle;</span>
        } else {
<span class="fc" id="L614">            theta = theta + angle;</span>
        }

        // Transform to 0 - 2PI range if we've gone all the way around circle
<span class="fc bfc" id="L618" title="All 2 branches covered.">        if (theta &gt; Math.PI * 2) {</span>
<span class="fc" id="L619">            theta -= Math.PI * 2;</span>
        }
<span class="fc bfc" id="L621" title="All 2 branches covered.">        if (theta &lt; 0) {</span>
<span class="fc" id="L622">            theta += Math.PI * 2;</span>
        }

        // Compute our deltas
<span class="fc" id="L626">        int dx = (int) (theOffset * Math.cos(theta));</span>
<span class="fc" id="L627">        int dy = (int) (theOffset * Math.sin(theta));</span>

        // For backward compatibility everything is above and right
        // TODO: Do in polar domain?
        if (aboveAndRight) {
            dx = Math.abs(dx);
            dy = -Math.abs(dy);
        }

<span class="fc" id="L636">        result.x += dx;</span>
<span class="fc" id="L637">        result.y += dy;</span>

//        LOG.log(Level.FINE,result.x + &quot;, &quot; + result.y
//                + &quot; theta = &quot; + theta * 180 / Math.PI
//                + &quot; dx = &quot; + dx + &quot; dy = &quot; + dy);

<span class="fc" id="L643">        return result;</span>
    }

    /**
     * Paint the virtual connection from the edge to where the path item
     * is placed according to this path item placement algorithm.
     *
     * @param g the Graphics object
     * @see org.tigris.gef.base.PathConv#paint(java.awt.Graphics)
     */
    public void paint(Graphics g) {
<span class="nc" id="L654">        final Point p1 = getAnchorPosition();</span>
<span class="nc" id="L655">        Point p2 = getPoint();</span>
<span class="nc" id="L656">        Rectangle r = itemFig.getBounds();</span>
        // Load the standard colour, just add an alpha channel.
<span class="nc" id="L658">        Color c = Globals.getPrefs().handleColorFor(itemFig);</span>
<span class="nc" id="L659">        c = new Color(c.getRed(), c.getGreen(), c.getBlue(), 100);</span>
<span class="nc" id="L660">        g.setColor(c);</span>
<span class="nc" id="L661">        r.grow(2, 2);</span>
<span class="nc" id="L662">        g.fillRoundRect(r.x, r.y, r.width, r.height, 8, 8);</span>
<span class="nc bnc" id="L663" title="All 2 branches missed.">        if (r.contains(p2)) {</span>
<span class="nc" id="L664">            p2 = getRectLineIntersection(r, p1, p2);</span>
        }
<span class="nc" id="L666">        g.drawLine(p1.x, p1.y, p2.x, p2.y);</span>
<span class="nc" id="L667">    }</span>

    /**
     * Finds the point where a rectangle and line intersect.
     * Finds the intersection point between the border of a Rectangle r and
     * a line drawn between two Points pOut (outside the rectangle) and pIn
     * (inside the rectangle).
     * If the pIn is not inside the rectangle, or if any other problem occurs,
     * pIn is returned.
     * @param r Rectangle to find the intersection of.
     * @param pOut Point outside the rectangle.
     * @param pIn Point inside the rectangle.
     * @return The intersection between Line(pOut, pIn) and Rectangle r.
     */
    private Point getRectLineIntersection(Rectangle r, Point pOut, Point pIn) {
        Line2D.Double m, n;
<span class="nc" id="L683">        m = new Line2D.Double(pOut, pIn);</span>
<span class="nc" id="L684">        n = new Line2D.Double(r.x, r.y, r.x + r.width, r.y);</span>
<span class="nc bnc" id="L685" title="All 2 branches missed.">        if (m.intersectsLine(n)) {</span>
<span class="nc" id="L686">            return intersection(m, n);</span>
        }
<span class="nc" id="L688">        n = new Line2D.Double(r.x + r.width, r.y, r.x + r.width,</span>
                r.y + r.height);
<span class="nc bnc" id="L690" title="All 2 branches missed.">        if (m.intersectsLine(n)) {</span>
<span class="nc" id="L691">            return intersection(m, n);</span>
        }
<span class="nc" id="L693">        n = new Line2D.Double(r.x, r.y + r.height, r.x + r.width,</span>
                r.y + r.height);
<span class="nc bnc" id="L695" title="All 2 branches missed.">        if (m.intersectsLine(n)) {</span>
<span class="nc" id="L696">            return intersection(m, n);</span>
        }
<span class="nc" id="L698">        n = new Line2D.Double(r.x, r.y, r.x, r.y + r.width);</span>
<span class="nc bnc" id="L699" title="All 2 branches missed.">        if (m.intersectsLine(n)) {</span>
<span class="nc" id="L700">            return intersection(m, n);</span>
        }
        // Should never get here.  If we do, return the inner point.
<span class="nc" id="L703">        LOG.log(Level.WARNING, &quot;Could not find rectangle intersection, using inner point.&quot;);</span>
<span class="nc" id="L704">        return pIn;</span>
    }

    /**
     * Finds the intersection point of two lines.
     * It is surprising that this method isn't already available in the base
     * Line2D class of Java.  If a stock method exists or is implemented in
     * future, feel free replace this code with it.
     * @param m First line.
     * @param n Second line.
     * @return Intersection point of first and second line.
     */
    private Point intersection(Line2D m, Line2D n) {
<span class="nc" id="L717">        double d = (n.getY2() - n.getY1()) * (m.getX2() - m.getX1())</span>
<span class="nc" id="L718">                - (n.getX2() - n.getX1()) * (m.getY2() - m.getY1());</span>
<span class="nc" id="L719">        double a = (n.getX2() - n.getX1()) * (m.getY1() - n.getY1())</span>
<span class="nc" id="L720">                - (n.getY2() - n.getY1()) * (m.getX1() - n.getX1());</span>

<span class="nc" id="L722">        double as = a / d;</span>

<span class="nc" id="L724">        double x = m.getX1() + as * (m.getX2() - m.getX1());</span>
<span class="nc" id="L725">        double y = m.getY1() + as * (m.getY2() - m.getY1());</span>
<span class="nc" id="L726">        return new Point((int) x, (int) y);</span>
    }

    /**
     * Returns the value of the percent field - the position of the anchor
     * point as a percentage of the edge.
     * @important Used by PGML.tee.
     * @return The value of the percent field.
     */
    public int getPercent() {
<span class="nc" id="L736">        return percent;</span>
    }

    /**
     * Returns the value of the angle field converted to degrees.
     * The angle of the path item relative to the edge.
     * @important Used by PGML.tee.
     * @return The value of the angle field in degrees.
     */
    public double getAngle() {
<span class="nc" id="L746">        return angle * 180 / Math.PI;</span>
    }

    /**
     * Returns the value of the vectorOffset field.
     * The vectorOffset field is the distance away from the edge, along the
     * path vector that the item Fig is placed.
     * @important Used by PGML.tee.
     * @return The value of the vectorOffset field.
     */
    public int getVectorOffset() {
<span class="nc" id="L757">        return vectorOffset;</span>
    }
    /** End of methods used by PGML.tee */

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>