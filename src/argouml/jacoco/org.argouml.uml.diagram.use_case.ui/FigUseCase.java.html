<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FigUseCase.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">argouml-app</a> &gt; <a href="index.source.html" class="el_package">org.argouml.uml.diagram.use_case.ui</a> &gt; <span class="el_source">FigUseCase.java</span></div><h1>FigUseCase.java</h1><pre class="source lang-java linenums">/* $Id$
 *******************************************************************************
 * Copyright (c) 2009-2010 Contributors - see below
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Bob Tarling
 *    Michiel van der Wulp
 *******************************************************************************
 *
 * Some portions of this file was previously release using the BSD License:
 */
// $Id$
// Copyright (c) 1996-2009 The Regents of the University of California. All
// Rights Reserved. Permission to use, copy, modify, and distribute this
// software and its documentation without fee, and without a written
// agreement is hereby granted, provided that the above copyright notice
// and this paragraph appear in all copies.  This software program and
// documentation are copyrighted by The Regents of the University of
// California. The software program and documentation are supplied &quot;AS
// IS&quot;, without any accompanying services from The Regents. The Regents
// does not warrant that the operation of the program will be
// uninterrupted or error-free. The end-user understands that the program
// was developed for research purposes and is advised not to rely
// exclusively on the program for any reason.  IN NO EVENT SHALL THE
// UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
// SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS,
// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE. THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY
// WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
// PROVIDED HEREUNDER IS ON AN &quot;AS IS&quot; BASIS, AND THE UNIVERSITY OF
// CALIFORNIA HAS NO OBLIGATIONS TO PROVIDE MAINTENANCE, SUPPORT,
// UPDATES, ENHANCEMENTS, OR MODIFICATIONS.

package org.argouml.uml.diagram.use_case.ui;


import java.awt.Color;
import java.awt.Dimension;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.event.MouseEvent;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;
import java.util.Vector;

import javax.swing.Action;

import org.argouml.model.Model;
import org.argouml.ui.ArgoJMenu;
import org.argouml.ui.targetmanager.TargetManager;
import org.argouml.uml.diagram.DiagramSettings;
import org.argouml.uml.diagram.ui.ActionAddExtensionPoint;
import org.argouml.uml.diagram.ui.ActionAddNote;
import org.argouml.uml.diagram.ui.ActionCompartmentDisplay;
import org.argouml.uml.diagram.ui.FigCompartment;
import org.argouml.uml.diagram.ui.FigCompartmentBox;
import org.argouml.uml.diagram.ui.FigExtensionPointsCompartment;
import org.tigris.gef.base.Selection;
import org.tigris.gef.presentation.Fig;
import org.tigris.gef.presentation.FigCircle;

/**
 * A fig to display use cases on use case diagrams.&lt;p&gt;
 *
 * Realized as a solid oval containing the name of the use
 * case. Optionally may be split into two compartments, with the lower
 * compartment displaying the extension points for the use case.&lt;p&gt;
 *
 * Implements all interfaces through its superclasses.&lt;p&gt;
 *
 * There is some coordinate geometry to be done to fit rectangular
 * text boxes inside an ellipse, and to draw a horizontal line 
 * at any height within the ellipse, touching the ellipse. 
 * In the following, we start from a coordinate 
 * system with the center at the center of the ellipse.
 * The rectangular text box contains the
 * name and any extension points if shown, and is deemed to be of
 * height &lt;em&gt;2h&lt;/em&gt; and width &lt;em&gt;2w&lt;/em&gt;. We allow a margin of
 * &lt;em&gt;p&lt;/em&gt; above the top and below the bottom of the box, so we
 * know the height of the ellipse, &lt;em&gt;2b&lt;/em&gt; = &lt;em&gt;2h&lt;/em&gt; +
 * &lt;em&gt;2p&lt;/em&gt;.&lt;p&gt;
 *
 * The formula for an ellipse of width &lt;em&gt;2a&lt;/em&gt; and height
 * &lt;em&gt;2b&lt;/em&gt;, centered on the origin, is&lt;p&gt;
 *
 * &lt;em&gt;x&lt;/em&gt;^2/&lt;em&gt;a&lt;/em&gt;^2 + &lt;em&gt;y&lt;/em&gt;^2/&lt;em&gt;b&lt;/em&gt;^2 = 1.&lt;p&gt;
 * or:&lt;p&gt;
 * xÂ²/aÂ² + yÂ²/bÂ² = 1&lt;p&gt;
 *
 * We know that a corner of the rectangle is at coordinate
 * (&lt;em&gt;w&lt;/em&gt;,&lt;em&gt;h&lt;/em&gt;), since the rectangle must also be centered
 * on the origin to fit within the ellipse. Substituting these values
 * for &lt;em&gt;x&lt;/em&gt; and &lt;em&gt;y&lt;/em&gt; in the formula above, we can compute
 * &lt;em&gt;a&lt;/em&gt;, half the width of the ellipse, since we know
 * &lt;em&gt;b&lt;/em&gt;.&lt;p&gt;
 *
 * &lt;em&gt;a&lt;/em&gt; = &lt;em&gt;wb&lt;/em&gt;/sqrt(&lt;em&gt;b&lt;/em&gt;^2 - &lt;em&gt;h&lt;/em&gt;^2).&lt;p&gt;
 *
 * But &lt;em&gt;b&lt;/em&gt; was defined in terms of the height of the rectangle
 * plus agreed padding at the top, so we can write.&lt;p&gt;
 *
 * &lt;em&gt;a&lt;/em&gt; = (&lt;em&gt;wh&lt;/em&gt; + &lt;em&gt;wb&lt;/em&gt;)/
 *                 sqrt(2&lt;em&gt;hp&lt;/em&gt; + &lt;em&gt;p&lt;/em&gt;^2)&lt;p&gt;
 *
 * Given we now know &lt;em&gt;a&lt;/em&gt; and &lt;em&gt;b&lt;/em&gt;, we can find the
 * coordinates of any partition line required between use case name
 * and extension points.&lt;p&gt;
 *
 * Finally we need to transform our coordinates, to recognise that the
 * origin is at our top left corner, and the Y coordinates are
 * reversed.&lt;p&gt;
 */
<span class="pc bpc" id="L120" title="1 of 2 branches missed.">public class FigUseCase extends FigCompartmentBox {</span>

    /**
     * The minimum padding allowed above the rectangle for
     * the use case name and extension points to the top of the use
     * case oval itself.
     */
    private static final int MIN_VERT_PADDING = 4;

    /**
     * The Fig for the extensionPoints compartment (if any).
     */
    private FigExtensionPointsCompartment extensionPointsFigCompartment;
    
    /**
     * Initialization which is common to multiple constructors.&lt;p&gt;
     * 
     * There should be no size calculations here, nor color setting,
     * since not all attributes are set yet (like e.g. fill color).
     */
    private void initialize(Rectangle bounds) {       
<span class="fc" id="L141">        enableSizeChecking(false);</span>
<span class="fc" id="L142">        setSuppressCalcBounds(true); </span>
        
<span class="fc" id="L144">        FigExtensionPointsCompartment epc =</span>
            /* Side effect: This creates the fig: */
<span class="fc" id="L146">            getExtensionPointsCompartment();</span>

        /*
         * A use case has an external separator.
         * External means external to the compartment box. 
         * This horizontal line sticks out of the box, 
         * and touches the ellipse edge.
         */
<span class="fc" id="L154">        Fig separatorFig = epc.getSeparatorFig();</span>
        
        /* TODO: This next line prevent loading a UseCase 
         * with a stereotype to grow. Why? */
<span class="fc" id="L158">        getStereotypeFig().setVisible(true);</span>
        
        // add Figs to the FigNode in back-to-front order
<span class="fc" id="L161">        addFig(getBigPort());</span>
<span class="fc" id="L162">        addFig(getNameFig());</span>
        // stereotype fig covers the name fig:
<span class="fc" id="L164">        addFig(getStereotypeFig());</span>
<span class="fc" id="L165">        addFig(epc);</span>
<span class="fc" id="L166">        addFig(separatorFig);</span>

        // Make all the parts match the main fig
<span class="fc" id="L169">        setFilled(true);</span>
<span class="fc" id="L170">        super.setFillColor(FILL_COLOR);</span>
<span class="fc" id="L171">        super.setLineColor(LINE_COLOR);</span>
<span class="fc" id="L172">        super.setLineWidth(LINE_WIDTH);</span>
        
        // by default, do not show extension points:
<span class="fc" id="L175">        setExtensionPointsVisible(false);</span>

        /* Set the drop location in the case of D&amp;D: */
<span class="fc bfc" id="L178" title="All 2 branches covered.">        if (bounds != null) {</span>
<span class="fc" id="L179">            setLocation(bounds.x, bounds.y);</span>
        }

<span class="fc" id="L182">        setSuppressCalcBounds(false);</span>
<span class="fc" id="L183">        setBounds(getBounds());</span>
<span class="fc" id="L184">        enableSizeChecking(true);</span>
<span class="fc" id="L185">    }</span>
    
    @Override
    protected Fig createBigPortFig() {
        /* Use arbitrary dimensions for now. */
<span class="fc" id="L190">        Fig b = new FigMyCircle(0, 0, 100, 60);</span>
<span class="fc" id="L191">        b.setFilled(true);</span>
<span class="fc" id="L192">        b.setFillColor(FILL_COLOR);</span>
<span class="fc" id="L193">        b.setLineColor(LINE_COLOR);</span>
<span class="fc" id="L194">        b.setLineWidth(LINE_WIDTH);</span>
<span class="fc" id="L195">        return b;</span>
    }

    /**
     * Construct a use case figure with the given owner, bounds, and rendering 
     * settings.  This constructor is used by the PGML parser.
     * 
     * @param owner owning model element
     * @param bounds position and size
     * @param settings rendering settings
     */
    public FigUseCase(Object owner, Rectangle bounds, 
            DiagramSettings settings) {
<span class="fc" id="L208">        super(owner, bounds, settings);</span>
<span class="fc" id="L209">        initialize(bounds);</span>
<span class="fc" id="L210">    }</span>

    /**
     * Build a collection of menu items relevant for a right-click
     * popup menu on a Use Case.&lt;p&gt;
     *
     * Adds to the generic pop up items from the parent.&lt;p&gt;
     *
     * @param me  The mouse event that generated this popup.
     *
     * @return    A collection of menu items
     */
    @Override
    public Vector getPopUpActions(MouseEvent me) {
        /* Check if multiple items are selected: */
<span class="nc bnc" id="L225" title="All 2 branches missed.">        boolean ms = TargetManager.getInstance().getTargets().size() &gt; 1;</span>

        // Get the parent vector first
<span class="nc" id="L228">        Vector popUpActions = super.getPopUpActions(me);</span>

        // Add menu to add an extension point or note. Placed one before last,
        // so the &quot;Properties&quot; entry is always last.
<span class="nc" id="L232">        ArgoJMenu addMenu = new ArgoJMenu(&quot;menu.popup.add&quot;);</span>

<span class="nc bnc" id="L234" title="All 2 branches missed.">        if (!ms) {</span>
<span class="nc" id="L235">            addMenu.add(ActionAddExtensionPoint.singleton());</span>
        }
<span class="nc" id="L237">        addMenu.add(new ActionAddNote());</span>

<span class="nc" id="L239">        popUpActions.add(popUpActions.size() - getPopupAddOffset(), addMenu);</span>

        // Modifier menu. Placed one before last, so the &quot;Properties&quot; entry is
        // always last.
<span class="nc" id="L243">        popUpActions.add(popUpActions.size() - getPopupAddOffset(),</span>
<span class="nc" id="L244">                buildModifierPopUp(LEAF | ROOT));</span>

<span class="nc" id="L246">        return popUpActions;</span>
    }

    /**
     * Show menu to display/hide the extension point compartment.
     * @return the menu
     * @see org.argouml.uml.diagram.ui.FigNodeModelElement#buildShowPopUp()
     */
    @Override
    protected ArgoJMenu buildShowPopUp() {
<span class="nc" id="L256">        ArgoJMenu showMenu = super.buildShowPopUp();</span>
<span class="nc" id="L257">        Iterator i = ActionCompartmentDisplay.getActions().iterator();</span>
<span class="nc bnc" id="L258" title="All 2 branches missed.">        while (i.hasNext()) {</span>
<span class="nc" id="L259">            showMenu.add((Action) i.next());</span>
        }
<span class="nc" id="L261">        return showMenu;</span>
    }

    /**
     * USED BY PGML.tee.
     * @return the class name and bounds together with compartment
     * visibility.
     */
    @Override
    public String classNameAndBounds() {
<span class="nc" id="L271">        return super.classNameAndBounds()</span>
<span class="nc" id="L272">                + &quot;extensionPointVisible=&quot; + isExtensionPointsVisible();</span>
    }

    public boolean isExtensionPointsVisible() {
<span class="nc bnc" id="L276" title="All 2 branches missed.">        return extensionPointsFigCompartment != null </span>
<span class="nc bnc" id="L277" title="All 2 branches missed.">            &amp;&amp; extensionPointsFigCompartment.isVisible();</span>
    }

    /**
     * Set the visibility of the extension point compartment. This is
     * called from outside this class when the user sets visibility
     * explicitly through the style panel or the context sensitive
     * pop-up menu.&lt;p&gt;
     *
     * We don't change the size of the use case, so we just have to
     * mark the extension point elements' visibility.
     * {@link #setBounds(int, int, int, int)} will do the relayout
     * (with name in the middle) for us.&lt;p&gt;
     *
     * @param isVisible  &lt;code&gt;true&lt;/code&gt; if the compartment should be shown,
     *                   &lt;code&gt;false&lt;/code&gt; otherwise.
     */
    public void setExtensionPointsVisible(boolean isVisible) {
<span class="fc" id="L295">        setCompartmentVisible(extensionPointsFigCompartment, isVisible);</span>
<span class="fc" id="L296">    }</span>

    /**
     * Creates a set of handles for dragging generalization/specializations
     *   or associations.&lt;p&gt;
     *
     * @return  The new selection object (a GEF entity).
     */
    @Override
    public Selection makeSelection() {
<span class="nc" id="L306">        return new SelectionUseCase(this);</span>
    }

    /**
     * Compute the dimensions of an ellipse that intersects the 4 corners 
     * of the given box.
     * 
     * @param box the width and height of the box
     * @return the dimension of the ellipse
     */
    public Dimension addCompartmentBoxSurroundings(Dimension box) {
<span class="fc" id="L317">        containerBox = box;</span>
        
        @SuppressWarnings(&quot;unused&quot;)
<span class="fc" id="L320">        double h = box.height;</span>
<span class="fc" id="L321">        double w = box.width;</span>

<span class="fc" id="L323">        int padding = Math.max((int) (w / 10.0), MIN_VERT_PADDING);</span>
<span class="fc" id="L324">        return calcEllipse(box, padding);</span>
    }

    /**
     * A private utility to calculate the bounding oval for the given
     * rectangular text box.&lt;p&gt;
     *
     * To sufficiently constrain the problem, we define that there is a gap
     * given by the parameter &lt;code&gt;vertPadding&lt;/code&gt; above the top of the
     * box to the top of the oval.&lt;p&gt;
     *
     * All computations are done in double, and then converted to integer at
     * the end.&lt;p&gt;
     *
     * @param rectSize     The dimensions of the rectangle to be bounded
     *
     * @param vertPadding  The padding between the top of the box and the top
     *                     of the ellipse.
     *
     * @return             The dimensions of the required oval.
     */
    private Dimension calcEllipse(Dimension rectSize, int vertPadding) {

        // Work out the radii of the ellipse, a and b. The top right corner of
        // the ellipse (Cartesian coordinates, centered on the origin) will be
        // at (x,y)

        double a;
<span class="fc" id="L352">        double b = rectSize.height / 2.0 + vertPadding;</span>

<span class="fc" id="L354">        double x = rectSize.width / 2.0;</span>
<span class="fc" id="L355">        double y = rectSize.height / 2.0;</span>

        // Formula for a is described in the overall class description.

<span class="fc" id="L359">        a = (x * b) / Math.sqrt(b * b - y * y);</span>

        // Result as integers, rounded up. We ensure that the radii are
        // integers for convenience.

<span class="fc" id="L364">        return new Dimension(((int) (Math.ceil(a) + getLineWidth()) * 2),</span>
<span class="fc" id="L365">			     ((int) (Math.ceil(b) + getLineWidth()) * 2));</span>
    }

    @Override
    protected Rectangle calculateCompartmentBoxDimensions(
            int x, int y, int w, int h) {
        /* For an ellipse, we can put the box in the middle:  */
<span class="fc" id="L372">        return new Rectangle(</span>
                x + (w - containerBox.width) / 2, 
                y + (h - containerBox.height) / 2, 
                containerBox.width, 
                containerBox.height);
    }

    @Override
    protected void setCompartmentBounds(FigCompartment c, 
            Rectangle cb, Rectangle ob) {
<span class="fc" id="L382">        Rectangle r = new Rectangle();</span>
<span class="fc" id="L383">        r.y = cb.y;</span>
<span class="fc" id="L384">        r.height = getLineWidth();</span>
<span class="fc" id="L385">        r.width = (int) (2.0 * (calcX(</span>
                ob.width / 2.0,
                ob.height / 2.0,
                ob.height / 2.0 - (cb.y - ob.y))));
<span class="fc" id="L389">        r.x = cb.x + cb.width / 2 - r.width / 2;</span>

<span class="fc" id="L391">        c.setExternalSeparatorFigBounds(r);            </span>
<span class="fc" id="L392">        c.setBounds(cb.x, cb.y, cb.width, cb.height);</span>
<span class="fc" id="L393">    }</span>

    /**
     * Private utility routine to work out the (positive) x coordinate of a
     * point on an oval, given the radii and y coordinate.&lt;p&gt;
     * TODO: Use this to calculate the separator lines!
     *
     * @param a  radius in X direction
     * @param b  radius in Y direction
     * @param y  Y coordinate
     * @return   Positive X coordinate for the given Y coordinate
     */
    private double calcX(double a, double b, double y) {
<span class="pc bpc" id="L406" title="2 of 4 branches missed.">        assert a &gt; 0;</span>
<span class="pc bpc" id="L407" title="2 of 4 branches missed.">        assert b &gt; 0;</span>
<span class="pc bpc" id="L408" title="2 of 4 branches missed.">        assert b &gt; y;</span>
<span class="fc" id="L409">        return (a * Math.sqrt(b * b - y * y)) / b;</span>
    }

    /**
     * Set the fill colour for the use case oval.&lt;p&gt;
     *
     * This involves setting the fill color of all figs, but not the bigPort.
     * Calling the super method would cause all FigGroup elements
     * to follow suit - which is not wanted for the bigPort nor the separator.
     *
     * @param col  The colour desired.
     */
    @Override
    public void setFillColor(Color col) {
<span class="fc" id="L423">        getBigPort().setFillColor(col);</span>
<span class="fc" id="L424">    }</span>
    
    public Color getFillColor() {
<span class="nc" id="L427">        return getBigPort().getFillColor();</span>
    }
    
    public boolean getFilled() {
<span class="nc" id="L431">        return getBigPort().isFilled();</span>
    }
    
    public boolean isFilled() {
<span class="nc" id="L435">        return getBigPort().isFilled();</span>
    }

    /**
     * Set whether the use case oval is to be filled.&lt;p&gt;
     *
     * This is overridden to have no effect as the use case is always filled
     * @param f this argument is ignored.
     */
    @Override
    public void setFilled(boolean f) {
        //
<span class="fc" id="L447">    }</span>

    /**
     * FigMyCircle is a FigCircle with corrected connectionPoint method:
     *   this methods calculates where a connected edge ends.&lt;p&gt;
     *   
     *   TODO: Once we are at GEF version 0.13.1M4, this whole class can be 
     *   removed, since it was taken over by GEF.
     */
    public static class FigMyCircle extends FigCircle {
        /**
         * Constructor just invokes the parent constructor.&lt;p&gt;
         *
         * @param x       X coordinate of the upper left corner of the bounding
         *                box.
         *
         * @param y       Y coordinate of the upper left corner of the bounding
         *                box.
         *
         * @param w       Width of the bounding box.
         *
         * @param h       Height of the bounding box.
         *
         * @param lColor  Line colour of the fig.
         *
         * @param fColor  Fill colour of the fig.
         */
        public FigMyCircle(int x, int y, int w, int h,
			   Color lColor,
			   Color fColor) {
<span class="fc" id="L477">            super(x, y, w, h, lColor, fColor);</span>
<span class="fc" id="L478">        }</span>

        /**
         * Constructor just invokes the parent constructor.&lt;p&gt;
         *
         * @param x       X coordinate of the upper left corner of the bounding
         *                box.
         *
         * @param y       Y coordinate of the upper left corner of the bounding
         *                box.
         *
         * @param w       Width of the bounding box.
         *
         * @param h       Height of the bounding box.
         */
        public FigMyCircle(int x, int y, int w, int h) {
<span class="fc" id="L494">            super(x, y, w, h);</span>
<span class="fc" id="L495">        }</span>

        /**
         * Compute the border point of the ellipse that is on the edge
         *   between the stored upper left corner and the given parameter.&lt;p&gt;
         *   
         *   TODO: Once we are at GEF version 0.13.1M4, this method 
         *   and in fact the whole class can be 
         *   removed, since it was taken over by GEF in revision 1279.
         *
         * @param anotherPt  The remote point to which an edge is drawn.
         *
         * @return           The connection point on the boundary of the
         *                   ellipse.
         */
        @Override
        public Point connectionPoint(Point anotherPt) {
<span class="fc" id="L512">            double rx = _w / 2;</span>
<span class="fc" id="L513">            double ry = _h / 2;</span>
<span class="fc" id="L514">            double dx = anotherPt.x - (_x + rx);</span>
<span class="fc" id="L515">            double dy = anotherPt.y - (_y + ry);</span>
<span class="fc" id="L516">            double dd = ry * ry * dx * dx + rx * rx * dy * dy;</span>
<span class="fc" id="L517">            double mu = rx * ry / Math.sqrt(dd);</span>

<span class="fc" id="L519">            Point res =</span>
		new Point((int) (mu * dx + _x + rx),
			  (int) (mu * dy + _y + ry));
<span class="fc" id="L522">            return res;</span>
        }

    }

    /*
     * Use the code from the FigCircle, not the one from Fig.
     */
    @Override
    public Point connectionPoint(Point anotherPt) {
<span class="fc" id="L532">        return getBigPort().connectionPoint(anotherPt);</span>
    }

    @Override
    protected void updateListeners(Object oldOwner, Object newOwner) {
<span class="nc" id="L537">        Set&lt;Object[]&gt; listeners = new HashSet&lt;Object[]&gt;();</span>
        /* Let's register for events from all modelelements
         * that change the name or body text: 
         */
<span class="nc bnc" id="L541" title="All 2 branches missed.">        if (newOwner != null) {</span>
            /* Register for name changes, added extensionPoints
             * and abstract makes the text italic.
             * All Figs need to listen to &quot;remove&quot;, too: */
<span class="nc" id="L545">            listeners.add(new Object[] {newOwner, </span>
                                new String[] {&quot;remove&quot;, &quot;name&quot;, &quot;isAbstract&quot;, 
                                    &quot;extensionPoint&quot;, &quot;stereotype&quot;}});
            
            // register for extension points:
<span class="nc bnc" id="L550" title="All 2 branches missed.">            for (Object ep : Model.getFacade().getExtensionPoints(newOwner)) {</span>
<span class="nc" id="L551">                listeners.add(new Object[] {ep, new String[] {&quot;location&quot;, &quot;name&quot;}});</span>
<span class="nc" id="L552">            }</span>
            
<span class="nc bnc" id="L554" title="All 2 branches missed.">            for (Object st : Model.getFacade().getStereotypes(newOwner)) {</span>
<span class="nc" id="L555">                listeners.add(new Object[] {st, &quot;name&quot;});</span>
<span class="nc" id="L556">            }</span>
        }
<span class="nc" id="L558">        updateElementListeners(listeners);</span>
<span class="nc" id="L559">    }</span>

    @Override
    public void renderingChanged() {
<span class="nc" id="L563">        super.renderingChanged();</span>
<span class="nc bnc" id="L564" title="All 2 branches missed.">        if (getOwner() != null) {</span>
<span class="nc" id="L565">            updateExtensionPoints();</span>
        }
<span class="nc" id="L567">    }</span>
    
    protected void updateExtensionPoints() {
<span class="nc bnc" id="L570" title="All 2 branches missed.">        if (!isExtensionPointsVisible()) {</span>
<span class="nc" id="L571">            return;</span>
        }
<span class="nc" id="L573">        extensionPointsFigCompartment.populate();</span>

<span class="nc" id="L575">        setBounds(getBounds());</span>
<span class="nc" id="L576">        damage();</span>
<span class="nc" id="L577">    }</span>
    
    /**
     * @return the Fig for the extension point compartment
     */
    public FigExtensionPointsCompartment getExtensionPointsCompartment() {
        // Set bounds will be called from our superclass constructor before
        // our constructor has run, so make sure this gets set up if needed.
<span class="pc bpc" id="L585" title="1 of 2 branches missed.">        if (extensionPointsFigCompartment == null) {</span>
<span class="fc" id="L586">            extensionPointsFigCompartment = new FigExtensionPointsCompartment(</span>
<span class="fc" id="L587">                    getOwner(),</span>
                    DEFAULT_COMPARTMENT_BOUNDS, 
<span class="fc" id="L589">                    getSettings());</span>
        }
<span class="fc" id="L591">        return extensionPointsFigCompartment;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>