<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>LabelledLayout.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">argouml-app</a> &gt; <a href="index.source.html" class="el_package">org.argouml.uml.ui</a> &gt; <span class="el_source">LabelledLayout.java</span></div><h1>LabelledLayout.java</h1><pre class="source lang-java linenums">/* $Id$
 *****************************************************************************
 * Copyright (c) 2009-2012 Contributors - see below
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    bobtarling
 *****************************************************************************
 *
 * Some portions of this file was previously release using the BSD License:
 */

// Copyright (c) 2008-2009 The Regents of the University of California. All
// Rights Reserved. Permission to use, copy, modify, and distribute this
// software and its documentation without fee, and without a written
// agreement is hereby granted, provided that the above copyright notice
// and this paragraph appear in all copies. This software program and
// documentation are copyrighted by The Regents of the University of
// California. The software program and documentation are supplied &quot;AS
// IS&quot;, without any accompanying services from The Regents. The Regents
// does not warrant that the operation of the program will be
// uninterrupted or error-free. The end-user understands that the program
// was developed for research purposes and is advised not to rely
// exclusively on the program for any reason. IN NO EVENT SHALL THE
// UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
// SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS,
// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE. THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY
// WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
// PROVIDED HEREUNDER IS ON AN &quot;AS IS&quot; BASIS, AND THE UNIVERSITY OF
// CALIFORNIA HAS NO OBLIGATIONS TO PROVIDE MAINTENANCE, SUPPORT,
// UPDATES, ENHANCEMENTS, OR MODIFICATIONS.

package org.argouml.uml.ui;

import java.awt.Component;
import java.awt.Container;
import java.awt.Dimension;
import java.awt.Insets;
import java.awt.LayoutManager;
import java.util.ArrayList;

import javax.swing.JComboBox;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.UIManager;

/**
 * This layout manager lines up components in 2 columns. All JLabels
 * are the first column and any component the JLabel is registered
 * with is in a second column next to the label. &lt;p&gt;
 *
 * Components are sized automatically to fill available space in the container
 * when it is resized. &lt;p&gt;
 * 
 * All JLabel widths will be the largest of the JLabel preferred widths (unless
 * the container is too narrow). &lt;p&gt;
 * 
 * The components will take up any left over width unless they are
 * restricted themselves by a maximum width. &lt;p&gt;
 * 
 * The height of each component is either fixed or will resize to use up any
 * available space in the container. Whether a components height is resizable
 * is determined by checking whether the preferred height of that component is
 * greater then its minimum height. This is the case for components such as
 * JList which would require to expand to show the maximum number or items. &lt;p&gt;
 * 
 * If a component is not to have its height resized then its preferred
 * height and minimum height should be the same. This is the case for
 * components such as JTextField and JComboBox* which should always stay the
 * same height. &lt;p&gt;
 * 
 * [There is known bug in JRE5 where the prefered height and minimum height of
 * a JComboBox can differ. LabelledLayout has coded a workaround for this bug.
 * See - http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6255154 ] &lt;p&gt;
 * 
 * LabelledLayout can show multiple panels of label/component
 * pairs. The seperation of these panels is indicated by adding a
 * Seperator component to the container. Labelled layout starts
 * a new panel when detecting this Seperator. &lt;p&gt;
 * 
 * When there are multiple panels, each panel is given equal width.
 * The width restriction of JLabels and components described above are then
 * dependent on panel width rather than container width.
 *
 * @author Bob Tarling
 */
public class LabelledLayout implements LayoutManager, java.io.Serializable {

    private static final long serialVersionUID = -5596655602155151443L;

    /**
     * This is the horizontal gap (in pixels) which specifies the space
     * between sections.  They can be changed at any time.
     * This should be a non negative integer.
     *
     * @serial
     * @see #getHgap()
     * @see #setHgap(int)
     */
    private int hgap;
    
    /**
     * This is the vertical gap (in pixels) which specifies the space
     * between rows.  They can be changed at any time.
     * This should be a non negative integer.
     *
     * @serial
     * @see #getVgap()
     * @see #setVgap(int)
     */
    private int vgap;

    private boolean ignoreSplitters;

    /**
     * Construct a new LabelledLayout.
     */
<span class="fc" id="L124">    public LabelledLayout() {</span>
<span class="fc" id="L125">        ignoreSplitters = false;</span>
<span class="fc" id="L126">        hgap = 0;</span>
<span class="fc" id="L127">        vgap = 0;</span>
<span class="fc" id="L128">    }</span>

    /**
     * Construct a new LabelledLayout.
     */
<span class="nc" id="L133">    public LabelledLayout(boolean ignoreSplitters) {</span>
<span class="nc" id="L134">        this.ignoreSplitters = ignoreSplitters;</span>
<span class="nc" id="L135">        this.hgap = 0;</span>
<span class="nc" id="L136">        this.vgap = 0;</span>
<span class="nc" id="L137">    }</span>

    /**
     * Construct a new horizontal LabelledLayout with the specified
     * cell spacing.
     * @param hgap The horizontal gap between components
     * @param vgap The vertical gap between components
     */
<span class="nc" id="L145">    public LabelledLayout(int hgap, int vgap) {</span>
<span class="nc" id="L146">        this.ignoreSplitters = false;</span>
<span class="nc" id="L147">        this.hgap = hgap;</span>
<span class="nc" id="L148">        this.vgap = vgap;</span>
<span class="nc" id="L149">    }</span>

    /** 
     * Adds the specified component with the specified name to the
     * layout. This is included to satisfy the LayoutManager interface
     * but is not actually used in this layout implementation.
     *
     * @param name the name of the component
     * @param comp the component to be added
     */
    public void addLayoutComponent(String name, Component comp) {
<span class="nc" id="L160">    }</span>

    /** 
     * Removes the specified component from
     * the layout. This is included to satisfy the LayoutManager
     * interface but is not actually used in this layout
     * implementation.
     *
     * @param comp the component
     */
    public void removeLayoutComponent(Component comp) {
<span class="nc" id="L171">    }</span>

    /**
     * Determines the preferred size of the container argument using
     * this labelled layout.  The preferred size is that all child
     * components are in one section at their own preferred size with
     * gaps and border indents.
     */
    public Dimension preferredLayoutSize(Container parent) {
<span class="nc" id="L180">        synchronized (parent.getTreeLock()) {</span>
<span class="nc" id="L181">            final Insets insets = parent.getInsets();</span>
<span class="nc" id="L182">            int preferredWidth = 0;</span>
<span class="nc" id="L183">            int preferredHeight = 0;</span>
<span class="nc" id="L184">            int widestLabel = 0;</span>

<span class="nc" id="L186">            final int componentCount = parent.getComponentCount();</span>
<span class="nc bnc" id="L187" title="All 2 branches missed.">            for (int i = 0; i &lt; componentCount; ++i) {</span>
<span class="nc" id="L188">                Component childComp = parent.getComponent(i);</span>
<span class="nc bnc" id="L189" title="All 4 branches missed.">                if (childComp.isVisible()</span>
                        &amp;&amp; !(childComp instanceof Seperator)) {
<span class="nc" id="L191">                    int childHeight = getPreferredHeight(childComp);</span>
<span class="nc bnc" id="L192" title="All 2 branches missed.">                    if (childComp instanceof JLabel) {</span>
<span class="nc" id="L193">                        final JLabel jlabel = (JLabel) childComp;</span>
<span class="nc" id="L194">                        widestLabel = </span>
<span class="nc" id="L195">                            Math.max(widestLabel, getPreferredWidth(jlabel));</span>
<span class="nc" id="L196">                        childComp = jlabel.getLabelFor();</span>
<span class="nc" id="L197">                        final int childWidth = getPreferredWidth(childComp);</span>
<span class="nc" id="L198">                        preferredWidth = </span>
<span class="nc" id="L199">                            Math.max(preferredWidth, childWidth);</span>

<span class="nc" id="L201">                        childHeight =</span>
<span class="nc" id="L202">                            Math.min(childHeight, getPreferredHeight(jlabel));</span>
                    }
<span class="nc" id="L204">                    preferredHeight += childHeight + this.vgap;</span>
                }
            }
<span class="nc" id="L207">            preferredWidth += insets.left + widestLabel + insets.right;</span>
<span class="nc" id="L208">            preferredHeight += insets.top + insets.bottom;</span>
<span class="nc" id="L209">            return new Dimension(</span>
                    insets.left + widestLabel + preferredWidth + insets.right,
                    preferredHeight);
        }
    }
    
    /** 
     * Required by LayoutManager.
     * 
     * @see java.awt.LayoutManager#minimumLayoutSize(java.awt.Container)
     */
    public Dimension minimumLayoutSize(Container parent) {
<span class="nc" id="L221">        synchronized (parent.getTreeLock()) {</span>
<span class="nc" id="L222">            final Insets insets = parent.getInsets();</span>
<span class="nc" id="L223">            int minimumHeight = insets.top + insets.bottom;</span>

<span class="nc" id="L225">            final int componentCount = parent.getComponentCount();</span>
<span class="nc bnc" id="L226" title="All 2 branches missed.">            for (int i = 0; i &lt; componentCount; ++i) {</span>
<span class="nc" id="L227">                Component childComp = parent.getComponent(i);</span>
<span class="nc bnc" id="L228" title="All 2 branches missed.">                if (childComp instanceof JLabel) {</span>
<span class="nc" id="L229">                    final JLabel jlabel = (JLabel) childComp;</span>
<span class="nc" id="L230">                    childComp = jlabel.getLabelFor();</span>
                    
<span class="nc" id="L232">                    final int childHeight = Math.max(</span>
<span class="nc" id="L233">                            getMinimumHeight(childComp),</span>
<span class="nc" id="L234">                            getMinimumHeight(jlabel));</span>
<span class="nc" id="L235">                    minimumHeight += childHeight + this.vgap;</span>
                }
            }
<span class="nc" id="L238">            return new Dimension(0, minimumHeight);</span>
        }
    }

    /**
     * @see java.awt.LayoutManager#layoutContainer(java.awt.Container)
     */
    public void layoutContainer(Container parent) {
<span class="nc" id="L246">        synchronized (parent.getTreeLock()) {</span>
<span class="nc" id="L247">            int sectionX = parent.getInsets().left;</span>

<span class="nc" id="L249">            final ArrayList&lt;Component&gt; components = new ArrayList&lt;Component&gt;();</span>
<span class="nc" id="L250">            final int sectionCount = getSectionCount(parent);</span>
<span class="nc" id="L251">            final int sectionWidth = getSectionWidth(parent, sectionCount);</span>
<span class="nc" id="L252">            int sectionNo = 0;</span>
<span class="nc bnc" id="L253" title="All 2 branches missed.">            for (int i = 0; i &lt; parent.getComponentCount(); ++i) {</span>
<span class="nc" id="L254">                final Component childComp = parent.getComponent(i);</span>
<span class="nc bnc" id="L255" title="All 2 branches missed.">                if (childComp instanceof Seperator) {</span>
<span class="nc bnc" id="L256" title="All 2 branches missed.">                    if (!this.ignoreSplitters) {</span>
<span class="nc" id="L257">                        layoutSection(</span>
                                parent, 
                                sectionX, 
                                sectionWidth, 
                                components, 
                                sectionNo++);
<span class="nc" id="L263">                        sectionX += sectionWidth + this.hgap;</span>
<span class="nc" id="L264">                        components.clear();</span>
                    }
                } else {
<span class="nc" id="L267">                    components.add(parent.getComponent(i));</span>
                }
            }
<span class="nc" id="L270">            layoutSection(</span>
                    parent, 
                    sectionX, 
                    sectionWidth, 
                    components, 
                    sectionNo);
<span class="nc" id="L276">        }</span>
<span class="nc" id="L277">    }</span>

    /** Determine the number of sections.  There is only ever one
     * section if oriented vertically.  If oriented horizontally the
     * number of sections is deduced from the number of Splitters in
     * the parent container.
     */
    private int getSectionCount(Container parent) {
<span class="nc" id="L285">        int sectionCount = 1;</span>
<span class="nc" id="L286">        final int componentCount = parent.getComponentCount();</span>
<span class="nc bnc" id="L287" title="All 2 branches missed.">        if (!ignoreSplitters) {</span>
<span class="nc bnc" id="L288" title="All 2 branches missed.">            for (int i = 0; i &lt; componentCount; ++i) {</span>
<span class="nc bnc" id="L289" title="All 2 branches missed.">                if (parent.getComponent(i) instanceof Seperator) {</span>
<span class="nc" id="L290">                    ++sectionCount;</span>
                }
            }
        }
<span class="nc" id="L294">        return sectionCount;</span>
    }
    
    /**
     * Determine the width of each section from the section count.
     * This is the working width minus the gaps between sections. This
     * result is then divided equally by the section count.
     */
    private int getSectionWidth(Container parent, int sectionCount) {
<span class="nc" id="L303">        return (getUsableWidth(parent) - (sectionCount - 1) * this.hgap)</span>
                / sectionCount;
    }

    /**
     * Determine the usable width of the parent.
     * This is the full width minus any borders.
     */
    private int getUsableWidth(Container parent) {
<span class="nc" id="L312">        final Insets insets = parent.getInsets();</span>
<span class="nc" id="L313">        return parent.getWidth() - (insets.left + insets.right);</span>
    }
    
    /**
     * Layout a single section
     */
    private void layoutSection(
            final Container parent,
            final int sectionX,
            final int sectionWidth,
            final ArrayList components,
            final int sectionNo) {
<span class="nc" id="L325">        final ArrayList&lt;Integer&gt; rowHeights = new ArrayList&lt;Integer&gt;();</span>

<span class="nc" id="L327">        final int componentCount = components.size();</span>
<span class="nc bnc" id="L328" title="All 2 branches missed.">        if (componentCount == 0) {</span>
<span class="nc" id="L329">            return;</span>
        }

<span class="nc" id="L332">        int labelWidth = 0;</span>
<span class="nc" id="L333">        int unknownHeightCount = 0;</span>
<span class="nc" id="L334">        int totalHeight = 0;</span>

        // Build up an array list of the heights of each label/component pair.
        // Heights of zero indicate a proportional height.
<span class="nc" id="L338">        Component previousComp = null;</span>
<span class="nc bnc" id="L339" title="All 2 branches missed.">        for (int i = 0; i &lt; componentCount; ++i) {</span>
<span class="nc" id="L340">            final Component childComp = (Component) components.get(i);</span>
            final int childHeight;
<span class="nc bnc" id="L342" title="All 2 branches missed.">            if (childComp instanceof JLabel) {</span>
<span class="nc" id="L343">                final JLabel jlabel = (JLabel) childComp;</span>
<span class="nc" id="L344">                final Component labelledComp = jlabel.getLabelFor();</span>
                
<span class="nc" id="L346">                labelWidth = Math.max(labelWidth, getPreferredWidth(jlabel));</span>
                
<span class="nc bnc" id="L348" title="All 2 branches missed.">                if (labelledComp != null) {</span>
<span class="nc" id="L349">                    ++i;</span>
<span class="nc" id="L350">                    childHeight = getChildHeight(labelledComp);</span>
<span class="nc bnc" id="L351" title="All 2 branches missed.">                    if (childHeight == 0) {</span>
<span class="nc" id="L352">                        ++unknownHeightCount;</span>
                    }
                } else {
<span class="nc" id="L355">                    childHeight = getPreferredHeight(jlabel);</span>
                }
                
<span class="nc" id="L358">                totalHeight += childHeight + this.vgap;</span>
<span class="nc" id="L359">                rowHeights.add(new Integer(childHeight));</span>
<span class="nc" id="L360">            } else {</span>
                // to manage the case there are no label/component
                // pairs but just one component
<span class="nc" id="L363">                childHeight = getChildHeight(childComp);</span>
<span class="nc bnc" id="L364" title="All 2 branches missed.">                if (childHeight == 0) {</span>
<span class="nc" id="L365">                    ++unknownHeightCount;</span>
                }
                
<span class="nc" id="L368">                totalHeight += childHeight + this.vgap;</span>
<span class="nc" id="L369">                rowHeights.add(new Integer(childHeight));</span>
            }
            
<span class="nc" id="L372">            previousComp = childComp;</span>
        }
<span class="nc" id="L374">        totalHeight -= this.vgap;</span>
        
<span class="nc" id="L376">        final Insets insets = parent.getInsets();</span>
<span class="nc" id="L377">        final int parentHeight = </span>
<span class="nc" id="L378">            parent.getHeight() - (insets.top + insets.bottom);</span>
        // Set the child components to the heights in the array list
        // calculating the height of any proportional component on the
        // fly.  FIXME - This assumes that the JLabel and the
        // component it labels have been added to the parent component
        // consecutively.
<span class="nc" id="L384">        int y = insets.top;</span>
<span class="nc" id="L385">        int row = 0;</span>
<span class="nc" id="L386">        previousComp = null;</span>
<span class="nc bnc" id="L387" title="All 2 branches missed.">        for (int i = 0; i &lt; componentCount; ++i) {</span>
<span class="nc" id="L388">            Component childComp = (Component) components.get(i);</span>
<span class="nc bnc" id="L389" title="All 2 branches missed.">            if (childComp.isVisible()) {</span>
                int rowHeight;
<span class="nc" id="L391">                int componentWidth = sectionWidth;</span>
<span class="nc" id="L392">                int componentX = sectionX;</span>
                // If the component is a JLabel which has another
                // component assigned then position/size the label and
                // calculate the size of the registered component
<span class="nc bnc" id="L396" title="All 2 branches missed.">                if (childComp instanceof JLabel</span>
<span class="nc bnc" id="L397" title="All 2 branches missed.">                        &amp;&amp; ((JLabel) childComp).getLabelFor() != null) {</span>
<span class="nc" id="L398">                    i++; // Assumes the next child is the labelled component</span>
<span class="nc" id="L399">                    final JLabel jlabel = (JLabel) childComp;</span>
<span class="nc" id="L400">                    childComp = jlabel.getLabelFor();</span>
<span class="nc" id="L401">                    jlabel.setBounds(sectionX, y, labelWidth,</span>
<span class="nc" id="L402">                                     getPreferredHeight(jlabel));</span>
<span class="nc" id="L403">                    componentWidth = sectionWidth - (labelWidth);</span>
<span class="nc" id="L404">                    componentX = sectionX + labelWidth;</span>
                }
<span class="nc" id="L406">                rowHeight = rowHeights.get(row).intValue();</span>
<span class="nc bnc" id="L407" title="All 2 branches missed.">                if (rowHeight == 0) {</span>
                    try {
<span class="nc" id="L409">                        rowHeight = calculateHeight(</span>
                                parentHeight, 
                                totalHeight, 
                                unknownHeightCount--, 
                                childComp);
<span class="nc" id="L414">                    } catch (ArithmeticException e) {</span>
                        String lookAndFeel = 
<span class="nc" id="L416">                            UIManager.getLookAndFeel().getClass().getName();</span>
<span class="nc" id="L417">                        throw new IllegalStateException(</span>
                                &quot;Division by zero laying out &quot;
<span class="nc" id="L419">                                + childComp.getClass().getName()</span>
<span class="nc" id="L420">                                + &quot; on &quot; + parent.getClass().getName()</span>
                                + &quot; in section &quot; + sectionNo
                                + &quot; using &quot;
                                + lookAndFeel,
                                e);
<span class="nc" id="L425">                    }</span>
<span class="nc" id="L426">                    totalHeight += rowHeight;</span>
                }
                // Make sure the component width isn't any greater
                // than its maximum allowed width
<span class="nc bnc" id="L430" title="All 2 branches missed.">                if (childComp.getMaximumSize() != null</span>
<span class="nc bnc" id="L431" title="All 2 branches missed.">                        &amp;&amp; getMaximumWidth(childComp) &lt; componentWidth) {</span>
<span class="nc" id="L432">                    componentWidth = getMaximumWidth(childComp);</span>
                }
<span class="nc" id="L434">                childComp.setBounds(componentX, y, componentWidth, rowHeight);</span>
<span class="nc" id="L435">                y += rowHeight + this.vgap;</span>
<span class="nc" id="L436">                ++row;</span>
<span class="nc" id="L437">                previousComp = childComp;</span>
            }
        }
<span class="nc" id="L440">    }</span>
    
    /**
     * @param childComp a component
     * @return 0 for a resizable component or a positive value for its fixed
     * height
     */
    private int getChildHeight(Component childComp) {
<span class="nc bnc" id="L448" title="All 2 branches missed.">        if (isResizable(childComp)) {</span>
            // If the child component is resizable then
            // we don't know it's actual size yet.
            // It will be calculated later as a
            // proportion of the available left over
            // space.  For now this is flagged as zero.
<span class="nc" id="L454">            return 0;</span>
        } else {
            // If a preferred height is not given or is
            // the same as the minimum height then fix the
            // height of this row.
<span class="nc" id="L459">            return getMinimumHeight(childComp);</span>
        }
    }

    /**
     * A component is resizable if its minimum size is less than
     * its preferred size.
     * There is a workaround here for a bug introduced in JRE5
     * where JComboBox minimum and preferred size now differ.
     * JComboBox is not resizable.
     * Anything in a JScrollPane is considered resizable
     * @param comp the component to check for resizability.
     * @return true if the given component should be resized to take u[p empty
     * space.
     */
    private boolean isResizable(Component comp) {
<span class="nc bnc" id="L475" title="All 2 branches missed.">        if (comp == null) {</span>
<span class="nc" id="L476">            return false;</span>
        }
<span class="nc bnc" id="L478" title="All 2 branches missed.">        if (comp instanceof JComboBox) {</span>
<span class="nc" id="L479">            return false;</span>
        }
<span class="nc bnc" id="L481" title="All 2 branches missed.">        if (comp.getPreferredSize() == null) {</span>
<span class="nc" id="L482">            return false;</span>
        }
<span class="nc bnc" id="L484" title="All 2 branches missed.">        if (comp.getMinimumSize() == null) {</span>
<span class="nc" id="L485">            return false;</span>
        }
<span class="nc bnc" id="L487" title="All 2 branches missed.">        return (getMinimumHeight(comp) &lt; getPreferredHeight(comp));</span>
    }

    private final int calculateHeight(
            final int parentHeight, 
            final int totalHeight,
            final int unknownHeightsLeft, 
            final Component childComp) {
<span class="nc" id="L495">        return Math.max(</span>
                (parentHeight - totalHeight) / unknownHeightsLeft,
<span class="nc" id="L497">                getMinimumHeight(childComp));</span>
    }
    
    private int getPreferredHeight(final Component comp) {
<span class="nc" id="L501">        return (int) comp.getPreferredSize().getHeight();</span>
    }
    
    private int getPreferredWidth(final Component comp) {
<span class="nc" id="L505">        return (int) comp.getPreferredSize().getWidth();</span>
    }

    private int getMinimumHeight(final Component comp) {
<span class="nc" id="L509">        return (int) comp.getMinimumSize().getHeight();</span>
    }
    
    private int getMaximumWidth(final Component comp) {
<span class="nc" id="L513">        return (int) comp.getMaximumSize().getWidth();</span>
    }
    
    /**
     * Create a new instance of the Separator that splits the layout in columns
     * @return the separator
     */
    public static Seperator getSeparator() {
<span class="fc" id="L521">        return new Seperator();</span>
    }

    /**
     * @return the horizontal gaps between components
     */
    public int getHgap() {
<span class="nc" id="L528">        return this.hgap;</span>
    }

    /**
     * Set the horizontal gaps between components
     * @param hgap the horizontal gap
     */
    public void setHgap(int hgap) {
<span class="fc" id="L536">        this.hgap = hgap;</span>
<span class="fc" id="L537">    }</span>

    /**
     * @return the vertical gaps between components
     */
    public int getVgap() {
<span class="nc" id="L543">        return this.vgap;</span>
    }

    /**
     * Set the vertical gaps between components
     * @param vgap the horizontal gap
     */
    public void setVgap(int vgap) {
<span class="nc" id="L551">        this.vgap = vgap;</span>
<span class="nc" id="L552">    }</span>
}

class Seperator extends JPanel {
    
    private static final long serialVersionUID = -4143634500959911688L;

<span class="fc" id="L559">    Seperator() {</span>
<span class="fc" id="L560">        super.setVisible(false);</span>
<span class="fc" id="L561">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>